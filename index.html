<!DOCTYPE html><html><head><title> Jiri Pospisil's blog</title><meta charset=utf-8 /><meta content="width=device-width, initial-scale=1" name=viewport /><link href="//cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.1.1/css/bootstrap.min.css" rel=stylesheet /><link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.0.3/css/font-awesome.min.css" rel=stylesheet /><link href="/stylesheets/application-646cf66d.css" rel=stylesheet /><link href="/images/favicon.ico" rel="shortcut icon" type="image/vnd.microsoft.icon"/><link href="/feed.xml" rel=alternate title="Jiri Pospisil's blog - Atom Feed" type="application/atom+xml"/></head><body><div class=container><div class=row><div class=col-sm-3><div class=hidden-xs><div class=avatar><a href="/"><img height=150px src="/images/avatar-c0869a08.jpg" width=150px /></a></div><div class=personal-info><h1>Jiří Pospíšil</h1><div class=icons><a href="https://github.com/mekishizufu"><i class="fa fa-github"></i></a><a href="https://twitter.com/JiriPospisil"><i class="fa fa-twitter"></i></a><a href="//stackoverflow.com/users/19093/jiri-pospisil"><i class="fa fa-stack-overflow"></i></a><a href="//jpospisil.com/feed.xml"><i class="fa fa-rss-square"></i></a></div><p>Hi! I'm a full stack developer currently working primarily with Ruby on Rails and Ember.js.</p><p>I work at <a href="//sensible.io">sensible.io</a>. We build applications for our clients and work on <a href="https://trackets.com">Trackets</a>.</p><p>I live in the Czech Republic, love reading and learning new things. I'm very passionate about technologies and computing in general.</p><p>You can get in touch with me at <a href="mailto:mekishizufu@gmail.com">mekishizufu@gmail.com</a></p></div><div class=articles-info><h5>Recent articles</h5><ul><li><a href="/2014/06/16/the-definitive-guide-to-arel-the-sql-manager-for-ruby.html">The definitive guide to Arel, the SQL manager for Ruby</a></li><li><a href="/2014/03/16/replacing-make-with-ninja.html">Replacing Make with Ninja</a></li></ul><h5>Archives</h5><ul><li><a href="/2014.html">2014 (2)</a></li></ul></div></div></div><div class=col-sm-9><div class=visible-xs><p>Written by <strong>Jiří Pospíšil</strong>, a full stack developer currently working primarily with Ruby on Rails and Ember.js.</p><p>You can get in touch with me at <a href="mailto:mekishizufu@gmail.com">mekishizufu@gmail.com</a></p><hr/></div><h1><a href="/2014/06/16/the-definitive-guide-to-arel-the-sql-manager-for-ruby.html">The definitive guide to Arel, the SQL manager for Ruby</a></h1><div class=published>Published on Jun 16, 2014</div><p>Arel is the kind of library that many of us Rails developers use on a daily basis and might not even know about it. So what&rsquo;s this library whose name only pops up when everything else fails all about?</p> <p>It&rsquo;s all about providing frameworks with a way of building and representing SQL queries. It&rsquo;s not the kind of library you would <em>typically</em> want to use directly (although you could as shown in a minute). Arel is meant to be the basic building block upon which frameworks build their own APIs that are more suitable for the end user.</p> <p>One of those frameworks is ActiveRecord (AR), the default ORM in Rails. ActiveRecord&rsquo;s responsibility is to provide a connection to the database, a convenient way to specify relationships between your models, provide a nice query interface and all the other things we enjoy.</p> <pre><code class="highlight ruby"><span class="c1"># ActiveRecord</span>
<span class="no">User</span><span class="p">.</span><span class="nf">first</span><span class="p">.</span><span class="nf">comments</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">created_at: </span><span class="mi">2</span><span class="p">.</span><span class="nf">days</span><span class="p">.</span><span class="nf">ago</span><span class="p">.</span><span class="nf">.</span><span class="no">Time</span><span class="p">.</span><span class="nf">current</span><span class="p">).</span><span class="nf">limit</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</code></pre> <p>Behind the scenes, ActiveRecord uses Arel to build the queries and ultimately calls out to it to get the final SQL before shipping it to the database of your choice.</p> <p>So how exactly Arel achieves building the queries in such a flexible way? By building an <a href="//en.wikipedia.org/wiki/Abstract_syntax_tree">AST</a>. Arel internally operates on AST nodes - you modify the query via a method call, Arel modifies or creates the appropriate node in the tree.</p> <div class=image> <img src="/images/arel/ast-02c47682.png" title="An select query represented via AST"/> </div> <p>This kind of representation holds two important properties. First, composability. By being composable you gain the power to build the query iteratively, piece by piece, and even combine several queries together. Many parts of the API (and consequently AR&rsquo;s API) would be impossible or at least very difficult handle without this property.</p> <pre><code class="highlight ruby"><span class="c1"># ActiveRecord</span>

<span class="n">bob</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">email: </span><span class="s2">"bob@test.com"</span><span class="p">).</span><span class="nf">where</span><span class="p">(</span><span class="ss">active: </span><span class="kp">true</span><span class="p">)</span>
<span class="c1"># =&gt; SELECT "users".* FROM "users" WHERE "users"."email" = 'bob@test.com' AND "users"."active" = 't'</span>

<span class="n">details</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="ss">:id</span><span class="p">,</span> <span class="ss">:email</span><span class="p">,</span> <span class="ss">:first_name</span><span class="p">).</span><span class="nf">order</span><span class="p">(</span><span class="nb">id</span><span class="p">:</span> <span class="ss">:desc</span><span class="p">)</span>
<span class="c1"># =&gt; SELECT "users"."id", "users"."email", "users"."first_name" FROM "users" ORDER BY "users"."id" DESC</span>

<span class="n">bob</span><span class="p">.</span><span class="nf">merge</span><span class="p">(</span><span class="n">details</span><span class="p">).</span><span class="nf">first</span>
<span class="c1"># =&gt; SELECT "users"."id", "users"."email", "users"."first_name" FROM "users"</span>
<span class="c1">#    WHERE "users"."email" = 'bob@test.com' AND "users"."active" = 't'</span>
<span class="c1">#    ORDER BY "users"."id" DESC LIMIT 1</span>
</code></pre> <p>While a contrived example, it is sufficient to show that it&rsquo;d be very difficult to work with these queries without some sort of abstract representation.</p> <p>The other equally important property is the completely obliviousness to the outside world. Arel doesn&rsquo;t care what&rsquo;s going to happen with the result. It might end up converted into a SQL query or into an entirely different format. In fact, Arel is able to convert the query into the Graphviz&rsquo;s dot format and you can create pretty diagrams out of it (more on that later).</p> <div class=image> <img src="/images/arel/arel_to_formats-ea4ad339.png" title="Arel converted to other formats"/> </div> <p>So far we&rsquo;ve seen only <a href="//guides.rubyonrails.org/active_record_querying.html">ActiveRecord&rsquo;s query interface</a>, the part built on top of Arel. Let&rsquo;s get below the surface and start working with Arel directly. To play along, use the following instructions. The script will download the correct version of libraries and leave you inside a Pry REPL instance (run <code>bundle console</code> if you&rsquo;ve left the REPL and want to come back). It&rsquo;s always a good idea to inspect all 3rd party scripts before you run them.</p> <pre><code class="highlight shell"><span class="nb">cd</span> /tmp
mkdir arel_playground <span class="o">&amp;&amp;</span> <span class="nb">cd </span>arel_playground

wget http://jpospisil.com/arel_setup.sh
<span class="c"># or</span>
curl -L -o arel_setup.sh http://jpospisil.com/arel_setup.sh

bash ./arel_setup.sh
</code></pre> <p>To stay current for the foreseeable future, the text is based on soon-to-be released version of Arel. The text also contains a lot of links to the actual Arel&rsquo;s source code, you are strongly encouraged to look around the file beyond the highlighted area to see all of the options!</p> <h2>Diving in with SelectManager</h2> <p>Let&rsquo;s start by building a select query that will give us all users. First, we need to create an object representing the table itself. Notice that you can name the table whatever you want, it doesn&rsquo;t have to exist anywhere.</p> <pre><code class="highlight ruby"><span class="n">users</span> <span class="o">=</span> <span class="no">Arel</span><span class="o">::</span><span class="no">Table</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:users</span><span class="p">)</span>
</code></pre> <p><code>Arel::Table</code> itself doesn&rsquo;t do much but it has <a href="https://github.com/rails/arel/blob/f50de54/lib/arel/table.rb#L45-L97">a lot of handy methods</a> which are responsible for delegating the calls deeper into the system. The method we are interested in now is the <a href="https://github.com/rails/arel/blob/f50de54/lib/arel/table.rb#L83-85">project</a> method. The name comes from <a href="//en.wikipedia.org/wiki/Projection_(relational_algebra)">relational algebra</a> but rest assured, it&rsquo;s just a plain <code>select</code>.</p> <pre><code class="highlight ruby"><span class="n">select_manager</span> <span class="o">=</span> <span class="n">users</span><span class="p">.</span><span class="nf">project</span><span class="p">(</span><span class="no">Arel</span><span class="p">.</span><span class="nf">star</span><span class="p">)</span>
</code></pre> <p>Notice the use of <a href="https://github.com/rails/arel/blob/f50de54/lib/arel.rb#L30-32">Arel.star</a>, a convenience method for the <code>*</code> character. What we got back is an instance of <a href="https://github.com/rails/arel/blob/f50de54/lib/arel/select_manager.rb">Arel::SelectManager</a>, the object responsible for assembling of the select query. Now we should be able to get the resulting SQL from <code>select_manager</code>.</p> <pre><code class="highlight ruby"><span class="n">select_manager</span><span class="p">.</span><span class="nf">to_sql</span>
<span class="c1"># =&gt; NoMethodError: undefined method `connection' for nil:NilClass</span>
</code></pre> <p>And it didn&rsquo;t work. If you think about it, the failure kind of makes sense (although the error should be handled more gracefully) because we didn&rsquo;t specified any database details and Arel has no way of knowing for what database we want the query generated. Databases may differ in syntax, capabilities and even in character escaping. Let&rsquo;s get ourselves an ActiveRecord database connection and try again.</p> <pre><code class="highlight ruby"><span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">.</span><span class="nf">establish_connection</span><span class="p">(</span><span class="ss">adapter: </span><span class="s2">"sqlite3"</span><span class="p">,</span> <span class="ss">database: </span><span class="s2">":memory:"</span><span class="p">)</span>

<span class="n">users</span>          <span class="o">=</span> <span class="no">Arel</span><span class="o">::</span><span class="no">Table</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:users</span><span class="p">,</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">)</span>
<span class="n">select_manager</span> <span class="o">=</span> <span class="n">users</span><span class="p">.</span><span class="nf">project</span><span class="p">(</span><span class="no">Arel</span><span class="p">.</span><span class="nf">star</span><span class="p">)</span>

<span class="n">select_manager</span><span class="p">.</span><span class="nf">to_sql</span>
<span class="c1"># =&gt; SELECT * FROM "users"</span>
</code></pre> <p>Notice we passed <code>ActiveRecord::Base</code> to the <code>Arel::Table</code>&rsquo;s constructor. We could have also set it globally via <code>Arel::Table.engine=</code>. With all that in place, we finally have our precious SQL query.</p> <p>The interesting thing is the collaboration between Arel and ActiveRecord. Arel is technically independent from ActiveRecord but it needs to get the database details from somewhere and currently it uses ActiveRecord. More specifically, Arel requires ActiveRecord&rsquo;s APIs. There&rsquo;s even a fake ActiveRecord implementation, <a href="https://github.com/rails/arel/blob/f50de54/test/support/fake_record.rb">FakeRecord</a>, that is <a href="https://github.com/rails/arel/blob/f50de54/test/helper.rb#L6-L7">used</a> to run the Arel&rsquo;s tests. In the past you needed a running MySQL server.</p> <h2>Getting picky</h2> <p>Querying for all users&#39; details is nice but let&rsquo;s be more specific. Say we want to select only the users&#39; ids and names. The key abstraction Arel provides for working with attributes (column names) is <a href="https://github.com/rails/arel/blob/f50de54/lib/arel/attributes/attribute.rb">Arel::Attribute</a>.</p> <p><code>Arel::Attribute</code> represents a single column of an arbitrary name. The easiest way to get a hold of an <code>Arel::Attribute</code> for a table is to use the <a href="https://github.com/rails/arel/blob/f50de54/lib/arel/table.rb#L99-101">Arel::Table#[]</a> method. We can use the result right away in the <code>project</code> method.</p> <pre><code class="highlight ruby"><span class="n">select_manager</span> <span class="o">=</span> <span class="n">users</span><span class="p">.</span><span class="nf">project</span><span class="p">(</span><span class="n">users</span><span class="p">[</span><span class="ss">:id</span><span class="p">],</span> <span class="n">users</span><span class="p">[</span><span class="ss">:name</span><span class="p">])</span>
<span class="n">select_manager</span><span class="p">.</span><span class="nf">to_sql</span>
<span class="c1"># =&gt; SELECT "users"."id", "users"."name" FROM "users</span>
</code></pre> <p>As you&rsquo;ve probably noticed, the class gets included with a bunch of modules which add a lot of functionality. The first module, <a href="https://github.com/rails/arel/blob/f50de54/lib/arel/expressions.rb">Arel::Expressions</a>, adds the common aggregate functions.</p> <pre><code class="highlight ruby"><span class="n">select_manager</span> <span class="o">=</span> <span class="n">users</span><span class="p">.</span><span class="nf">project</span><span class="p">(</span><span class="n">users</span><span class="p">[</span><span class="ss">:comments_count</span><span class="p">].</span><span class="nf">average</span><span class="p">)</span>
<span class="n">select_manager</span><span class="p">.</span><span class="nf">to_sql</span>
<span class="c1"># =&gt; SELECT AVG("users"."comments_count") AS avg_id FROM "users"</span>
</code></pre> <p>The results of these aggregate functions are kept in variables with hardcoded names (<code>avg_id</code> in this case). Fortunately, <a href="https://github.com/rails/arel/blob/f50de54/lib/arel/alias_predication.rb">Arel::AliasPredication</a> comes to our rescue.</p> <pre><code class="highlight ruby"><span class="n">select_manager</span> <span class="o">=</span> <span class="n">users</span><span class="p">.</span><span class="nf">project</span><span class="p">(</span><span class="n">users</span><span class="p">[</span><span class="ss">:vip</span><span class="p">].</span><span class="nf">as</span><span class="p">(</span><span class="s2">"status"</span><span class="p">),</span> <span class="n">users</span><span class="p">[</span><span class="ss">:vip</span><span class="p">].</span><span class="nf">count</span><span class="p">.</span><span class="nf">as</span><span class="p">(</span><span class="s2">"count"</span><span class="p">)).</span><span class="nf">group</span><span class="p">(</span><span class="s2">"vip"</span><span class="p">)</span>
<span class="n">select_manager</span><span class="p">.</span><span class="nf">to_sql</span>
<span class="c1"># =&gt; SELECT "users"."vip" AS status, COUNT("users"."vip") AS count FROM "users"  GROUP BY vip</span>
</code></pre> <p>The <a href="https://github.com/rails/arel/blob/f50de54/lib/arel/math.rb">Arel::Math</a> module is pretty neat. It implements the common math operators so that we can use them directly on the attributes as if we&rsquo;re working with the values.</p> <pre><code class="highlight ruby"><span class="n">select_manager</span> <span class="o">=</span> <span class="n">users</span><span class="p">.</span><span class="nf">project</span><span class="p">((</span><span class="n">users</span><span class="p">[</span><span class="ss">:stared_comments_count</span><span class="p">]</span> <span class="o">/</span> <span class="n">users</span><span class="p">[</span><span class="ss">:comments_count</span><span class="p">]).</span><span class="nf">as</span><span class="p">(</span><span class="s2">"ratio"</span><span class="p">))</span>
<span class="n">select_manager</span><span class="p">.</span><span class="nf">to_sql</span>
<span class="c1"># =&gt; SELECT "users"."stared_comments_count" / "users"."comments_count" AS ratio FROM "users"</span>
</code></pre> <h2>Extending our index finger</h2> <p>Select queries which return data from the whole table are quite rare, usually you want to have more fine grained control. Let&rsquo;s see how Arel handles these cases. The starting point is again <a href="https://github.com/rails/arel/blob/f50de54/lib/arel/attributes/attribute.rb">Arel::Attribute</a>. More specifically, it&rsquo;s one of its included modules, <a href="https://github.com/rails/arel/blob/f50de54/lib/arel/predications.rb">Arel::Predications</a>. By looking at the code you can see a lot of handy methods, many of which do not have their equivalent in ActiveRecord&#39; APIs.</p> <pre><code class="highlight ruby"><span class="n">select_manager</span> <span class="o">=</span> <span class="n">users</span><span class="p">.</span><span class="nf">project</span><span class="p">(</span><span class="no">Arel</span><span class="p">.</span><span class="nf">star</span><span class="p">).</span><span class="nf">where</span><span class="p">(</span><span class="n">users</span><span class="p">[</span><span class="ss">:id</span><span class="p">].</span><span class="nf">eq</span><span class="p">(</span><span class="mi">23</span><span class="p">).</span><span class="nf">or</span><span class="p">(</span><span class="n">users</span><span class="p">[</span><span class="ss">:id</span><span class="p">].</span><span class="nf">eq</span><span class="p">(</span><span class="mi">42</span><span class="p">)))</span>
<span class="n">select_manager</span> <span class="o">=</span> <span class="n">users</span><span class="p">.</span><span class="nf">project</span><span class="p">(</span><span class="no">Arel</span><span class="p">.</span><span class="nf">star</span><span class="p">).</span><span class="nf">where</span><span class="p">(</span><span class="n">users</span><span class="p">[</span><span class="ss">:id</span><span class="p">].</span><span class="nf">eq_any</span><span class="p">([</span><span class="mi">23</span><span class="p">,</span> <span class="mi">42</span><span class="p">]))</span>
<span class="n">select_manager</span><span class="p">.</span><span class="nf">to_sql</span>
<span class="c1"># =&gt; SELECT * FROM "users"  WHERE ("users"."id" = 23 OR "users"."id" = 42)</span>
</code></pre> <p>For more complicated queries, it&rsquo;s usually best to the build the parts individually and combine them together at the end.</p> <pre><code class="highlight ruby"><span class="n">admins_vips</span>    <span class="o">=</span> <span class="n">users</span><span class="p">[</span><span class="ss">:admin</span><span class="p">].</span><span class="nf">eq</span><span class="p">(</span><span class="kp">true</span><span class="p">).</span><span class="nf">or</span><span class="p">(</span><span class="n">users</span><span class="p">[</span><span class="ss">:vip</span><span class="p">].</span><span class="nf">eq</span><span class="p">(</span><span class="kp">true</span><span class="p">))</span>
<span class="n">with_karma</span>     <span class="o">=</span> <span class="n">users</span><span class="p">[</span><span class="ss">:karma</span><span class="p">].</span><span class="nf">gteq</span><span class="p">(</span><span class="mi">5000</span><span class="p">).</span><span class="nf">and</span><span class="p">(</span><span class="n">users</span><span class="p">[</span><span class="ss">:hellbanned</span><span class="p">].</span><span class="nf">eq</span><span class="p">(</span><span class="kp">false</span><span class="p">))</span>

<span class="n">select_manager</span> <span class="o">=</span> <span class="n">users</span><span class="p">.</span><span class="nf">project</span><span class="p">(</span><span class="n">users</span><span class="p">[</span><span class="ss">:id</span><span class="p">]).</span><span class="nf">where</span><span class="p">(</span><span class="n">admins_vips</span><span class="p">.</span><span class="nf">or</span><span class="p">(</span><span class="n">with_karma</span><span class="p">)).</span><span class="nf">order</span><span class="p">(</span><span class="n">users</span><span class="p">[</span><span class="ss">:id</span><span class="p">].</span><span class="nf">desc</span><span class="p">)</span>
<span class="n">select_manager</span><span class="p">.</span><span class="nf">to_sql</span>
<span class="c1"># =&gt; SELECT COUNT("users"."id") FROM "users" WHERE (("users"."admin" = 't' OR "users"."vip" = 't') </span>
<span class="c1">#      OR "users"."karma" &gt;= 5000 AND "users"."hellbanned" = 'f')</span>
<span class="c1">#    ORDER BY "users"."id" DESC</span>
</code></pre> <h2>The more the merrier</h2> <p>Next, let&rsquo;s take a look at join statements. In line with the previously shown API, Arel <a href="https://github.com/rails/arel/blob/f50de54/lib/arel/select_manager.rb#L104-119">exposes joins</a> directly from <code>Arel::SelectManager</code>. As expected, Arel supports the usual <code>INNER JOIN</code>, and <code>LEFT</code>, <code>RIGHT</code>, <code>FULL</code> <code>OUTER JOIN</code> kinds. </p> <pre><code class="highlight ruby"><span class="n">comments</span>       <span class="o">=</span> <span class="no">Arel</span><span class="o">::</span><span class="no">Table</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:comments</span><span class="p">,</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">)</span>

<span class="n">select_manager</span> <span class="o">=</span> <span class="n">users</span><span class="p">.</span><span class="nf">project</span><span class="p">(</span><span class="no">Arel</span><span class="p">.</span><span class="nf">star</span><span class="p">).</span><span class="nf">join</span><span class="p">(</span><span class="n">comments</span><span class="p">).</span><span class="nf">on</span><span class="p">(</span><span class="n">users</span><span class="p">[</span><span class="ss">:id</span><span class="p">].</span><span class="nf">eq</span><span class="p">(</span><span class="n">comments</span><span class="p">[</span><span class="ss">:user_id</span><span class="p">]))</span>
<span class="n">select_manager</span><span class="p">.</span><span class="nf">to_sql</span>
<span class="c1"># =&gt; SELECT * FROM "users" INNER JOIN "comments" ON "users"."id" = "comments"."user_id"</span>
</code></pre> <p>To create the remaining kinds of joins, we need to explicitly pass a second argument to the <code>join</code> method.</p> <pre><code class="highlight ruby"><span class="n">select_manager</span> <span class="o">=</span> <span class="n">users</span><span class="p">.</span><span class="nf">project</span><span class="p">(</span><span class="no">Arel</span><span class="p">.</span><span class="nf">star</span><span class="p">).</span><span class="nf">join</span><span class="p">(</span><span class="n">comments</span><span class="p">,</span> <span class="no">Arel</span><span class="o">::</span><span class="no">Nodes</span><span class="o">::</span><span class="no">OuterJoin</span><span class="p">).</span>
  <span class="nf">on</span><span class="p">(</span><span class="n">users</span><span class="p">[</span><span class="ss">:id</span><span class="p">].</span><span class="nf">eq</span><span class="p">(</span><span class="n">comments</span><span class="p">[</span><span class="ss">:user_id</span><span class="p">])).</span>
  <span class="nf">having</span><span class="p">(</span><span class="n">comments</span><span class="p">[</span><span class="ss">:id</span><span class="p">].</span><span class="nf">count</span><span class="p">.</span><span class="nf">lteq</span><span class="p">(</span><span class="mi">16</span><span class="p">)).</span>
  <span class="nf">take</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>

<span class="n">select_manager</span><span class="p">.</span><span class="nf">to_sql</span>
<span class="c1"># =&gt; SELECT * FROM "users" LEFT OUTER JOIN "comments" ON "users"."id" = "comments"."user_id" </span>
<span class="c1">#    HAVING COUNT("comments"."id") &lt;= 16 LIMIT 15</span>
</code></pre> <p>Since the need for <code>OuterJoin</code> is very common, there&rsquo;s a shortcut called <a href="https://github.com/rails/arel/blob/f50de54/lib/arel/select_manager.rb#L117-119">outer_join</a>, which internally calls the <code>join</code> method with the <code>Arel::Nodes::OuterJoin</code> argument for us. To get the remaining kinds of joins, there are <code>Arel::Nodes::FullOuterJoin</code> and <code>Arel::Nodes::RightOuterJoin</code> nodes available.</p> <p>The rarely used <code>CROSS JOIN</code> kind is not directly supported. What&rsquo;s also not supported out of the box is the <code>USING</code> clause but as with the previous case, we can get around that by resorting to creating <code>Arel::Nodes::SqlLiteral</code> manually or better yet by rewriting the query to use the supported constructs.</p> <h2>There&rsquo;s always more</h2> <p>Arel comes with support even for slightly advanced features such as <code>WITH</code> statements or <code>WINDOW</code> functions. Let&rsquo;s try to replicate an example <a href="//www.postgresql.org/docs/9.3/static/queries-with.html">7.8.1. SELECT in WITH</a> from the PostgreSQL manual. The query is quite complicated, it consists of 2 <code>WITH</code> statements and a few subqueries. Let&rsquo;s focus first on the <code>WITH</code> clauses <code>regional_sales</code> and <code>top_regions</code>.</p> <pre><code class="highlight ruby"><span class="n">orders</span>          <span class="o">=</span> <span class="no">Arel</span><span class="o">::</span><span class="no">Table</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:orders</span><span class="p">,</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">)</span>
<span class="n">reg_sales</span>       <span class="o">=</span> <span class="no">Arel</span><span class="o">::</span><span class="no">Table</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:regional_sales</span><span class="p">,</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">)</span>
<span class="n">top_regions</span>     <span class="o">=</span> <span class="no">Arel</span><span class="o">::</span><span class="no">Table</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:top_regions</span><span class="p">,</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">)</span>

<span class="n">reg_sales_query</span> <span class="o">=</span> <span class="n">orders</span><span class="p">.</span><span class="nf">project</span><span class="p">(</span><span class="n">orders</span><span class="p">[</span><span class="ss">:region</span><span class="p">],</span> <span class="n">orders</span><span class="p">[</span><span class="ss">:amount</span><span class="p">].</span><span class="nf">sum</span><span class="p">.</span><span class="nf">as</span><span class="p">(</span><span class="s2">"total_sales"</span><span class="p">)).</span>
                    <span class="nf">group</span><span class="p">(</span><span class="n">orders</span><span class="p">[</span><span class="ss">:region</span><span class="p">])</span>
<span class="n">reg_sales_as</span>    <span class="o">=</span> <span class="no">Arel</span><span class="o">::</span><span class="no">Nodes</span><span class="o">::</span><span class="no">As</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">reg_sales</span><span class="p">,</span> <span class="n">reg_sales_query</span><span class="p">)</span>
</code></pre> <p>Nothing we haven&rsquo;t seen before. The only exception is the explicit instantiation of <code>Arel::Nodes::As</code>. There doesn&rsquo;t seem to be a way around it as you cannot create an alias via the usual <code>as</code> method. </p> <pre><code class="highlight ruby"><span class="n">top_regions_subquery</span> <span class="o">=</span> <span class="n">reg_sales</span><span class="p">.</span><span class="nf">project</span><span class="p">(</span><span class="no">Arel</span><span class="p">.</span><span class="nf">sql</span><span class="p">(</span><span class="s2">"SUM(total_sales) / 10"</span><span class="p">))</span>
<span class="n">top_regions_query</span>    <span class="o">=</span> <span class="n">reg_sales</span><span class="p">.</span><span class="nf">project</span><span class="p">(</span><span class="n">reg_sales</span><span class="p">[</span><span class="ss">:region</span><span class="p">]).</span>
                        <span class="nf">where</span><span class="p">(</span><span class="n">reg_sales</span><span class="p">[</span><span class="ss">:total_sales</span><span class="p">].</span><span class="nf">gt</span><span class="p">(</span><span class="n">top_regions_subquery</span><span class="p">))</span>
<span class="n">top_regions_as</span>       <span class="o">=</span> <span class="no">Arel</span><span class="o">::</span><span class="no">Nodes</span><span class="o">::</span><span class="no">As</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">top_regions</span><span class="p">,</span> <span class="n">top_regions_query</span><span class="p">)</span>
</code></pre> <p>The use of <a href="https://github.com/rails/arel/blob/f50de54/lib/arel.rb#L26-L28">Arel.sql</a> is not ideal, however, as with the previous part, there is not a way to use math operations on the result of the <code>sum</code> call.</p> <pre><code class="highlight ruby"><span class="n">attributes</span> <span class="o">=</span> <span class="p">[</span><span class="n">orders</span><span class="p">[</span><span class="ss">:region</span><span class="p">],</span> <span class="n">orders</span><span class="p">[</span><span class="ss">:product</span><span class="p">],</span> <span class="n">orders</span><span class="p">[</span><span class="ss">:quantity</span><span class="p">].</span><span class="nf">as</span><span class="p">(</span><span class="s2">"product_units"</span><span class="p">),</span>
               <span class="n">orders</span><span class="p">[</span><span class="ss">:amount</span><span class="p">].</span><span class="nf">as</span><span class="p">(</span><span class="s2">"product_sales"</span><span class="p">)]</span>

<span class="n">res</span> <span class="o">=</span> <span class="n">orders</span><span class="p">.</span><span class="nf">project</span><span class="p">(</span><span class="o">*</span><span class="n">attributes</span><span class="p">).</span><span class="nf">where</span><span class="p">(</span><span class="n">orders</span><span class="p">[</span><span class="ss">:region</span><span class="p">].</span><span class="nf">in</span><span class="p">(</span><span class="n">top_regions</span><span class="p">.</span><span class="nf">project</span><span class="p">(</span><span class="n">top_regions</span><span class="p">[</span><span class="ss">:region</span><span class="p">]))).</span>
        <span class="nf">with</span><span class="p">([</span><span class="n">reg_sales_as</span><span class="p">,</span> <span class="n">top_regions_as</span><span class="p">]).</span><span class="nf">group</span><span class="p">(</span><span class="n">orders</span><span class="p">[</span><span class="ss">:region</span><span class="p">],</span> <span class="n">orders</span><span class="p">[</span><span class="ss">:product</span><span class="p">])</span>

<span class="n">res</span><span class="p">.</span><span class="nf">to_sql</span>
</code></pre> <p>With all of that in place, we have our final query. If we look at the parts individually, they are pretty simple. Overall, however, the code is longer than a pure SQL solution. The fact doesn&rsquo;t matter when using Arel pragmatically but if composed by hand, one has to always consider whether it&rsquo;s actually worth the effort.</p> <h2>SelectManager is not the only one</h2> <p>So far all we&rsquo;ve been doing was writing select queries via <code>SelectManager</code>, but Arel of course supports the other operations as well. Let&rsquo;s quickly take a look at deleting. There are two ways you can create a delete query. The first way is to explicitly instantiate <a href="https://github.com/rails/arel/blob/f50de54/lib/arel/delete_manager.rb">Arel::DeleteManager</a>.</p> <pre><code class="highlight ruby"><span class="n">delete_manager</span> <span class="o">=</span> <span class="no">Arel</span><span class="o">::</span><span class="no">DeleteManager</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">)</span>
<span class="n">delete_manager</span><span class="p">.</span><span class="nf">from</span><span class="p">(</span><span class="n">users</span><span class="p">).</span><span class="nf">where</span><span class="p">(</span><span class="n">users</span><span class="p">[</span><span class="ss">:id</span><span class="p">].</span><span class="nf">eq_any</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">]))</span>
<span class="n">delete_manager</span><span class="p">.</span><span class="nf">to_sql</span>
<span class="c1"># =&gt; DELETE FROM "users" WHERE ("users"."id" = 4 OR "users"."id" = 8)</span>
</code></pre> <p>The other way, although it seems deprecated, is to create the delete statement from a select statement by calling <a href="https://github.com/rails/arel/blob/f50de54/lib/arel/crud.rb#L32-37">compile_delete</a> (there are similar methods for the other operations as well). By looking at the code we can see that all it does is pick values out of the object it&rsquo;s mixed into (<code>Arel::SelectManager</code>) and passing it to a new instance of <code>Arel::DeleteManager</code>.</p> <pre><code class="highlight ruby"><span class="n">select_manager</span> <span class="o">=</span> <span class="n">users</span><span class="p">.</span><span class="nf">project</span><span class="p">(</span><span class="n">users</span><span class="p">[</span><span class="ss">:id</span><span class="p">],</span> <span class="n">users</span><span class="p">[</span><span class="ss">:name</span><span class="p">]).</span><span class="nf">where</span><span class="p">(</span><span class="n">users</span><span class="p">[</span><span class="ss">:banned</span><span class="p">].</span><span class="nf">eq</span><span class="p">(</span><span class="kp">true</span><span class="p">))</span>
<span class="n">select_manager</span><span class="p">.</span><span class="nf">to_sql</span>
<span class="c1"># =&gt; SELECT "users"."id", "users"."name" FROM "users"  WHERE "users"."banned = 't'</span>

<span class="n">delete_manager</span> <span class="o">=</span> <span class="n">select_manager</span><span class="p">.</span><span class="nf">compile_delete</span>
<span class="n">delete_manager</span><span class="p">.</span><span class="nf">to_sql</span>
<span class="c1"># =&gt; DELETE FROM "users" WHERE "users"."banned" = 't'</span>
</code></pre> <p>The managers for the remaining operations, <a href="https://github.com/rails/arel/blob/f50de54/lib/arel/insert_manager.rb">InsertManager</a> and <a href="https://github.com/rails/arel/blob/f50de54/lib/arel/update_manager.rb">UpdateManager</a>, work in a similar fashion. </p> <pre><code class="highlight ruby"><span class="n">insert_manager</span> <span class="o">=</span> <span class="no">Arel</span><span class="o">::</span><span class="no">InsertManager</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">)</span>
<span class="n">insert_manager</span><span class="p">.</span><span class="nf">insert</span><span class="p">([[</span><span class="n">users</span><span class="p">[</span><span class="ss">:name</span><span class="p">],</span> <span class="s2">"Bob"</span><span class="p">],</span> <span class="p">[</span><span class="n">users</span><span class="p">[</span><span class="ss">:admin</span><span class="p">],</span> <span class="kp">true</span><span class="p">]])</span>
<span class="n">insert_manager</span><span class="p">.</span><span class="nf">to_sql</span>
<span class="c1"># =&gt; INSERT INTO "users" ("name", "admin) VALUES ('Bob', 't')</span>
</code></pre> <p>Notice that <code>Arel::InsertManager</code> is able to figure out the name of the table we&rsquo;re inserting to automatically through the use of <code>Arel::Attribute</code>. If we&rsquo;re to use string literals instead, we&rsquo;d have to specify the table name via the <a href="https://github.com/rails/arel/blob/f50de54/lib/arel/insert_manager.rb#L8-11">into</a> method. The same is not offered in <code>Arel::UpdateManager</code> and we have to use <a href="https://github.com/rails/arel/blob/f50de54/lib/arel/update_manager.rb#L29-32">table</a>.</p> <pre><code class="highlight ruby"><span class="n">update_manager</span> <span class="o">=</span> <span class="no">Arel</span><span class="o">::</span><span class="no">UpdateManager</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">)</span>
<span class="n">update_manager</span><span class="p">.</span><span class="nf">table</span><span class="p">(</span><span class="n">users</span><span class="p">).</span><span class="nf">where</span><span class="p">(</span><span class="n">users</span><span class="p">[</span><span class="ss">:id</span><span class="p">].</span><span class="nf">eq</span><span class="p">(</span><span class="mi">42</span><span class="p">))</span>
<span class="n">update_manager</span><span class="p">.</span><span class="nf">set</span><span class="p">([[</span><span class="n">users</span><span class="p">[</span><span class="ss">:name</span><span class="p">],</span> <span class="s2">"Bob"</span><span class="p">],</span> <span class="p">[</span><span class="n">users</span><span class="p">[</span><span class="ss">:admin</span><span class="p">],</span> <span class="kp">true</span><span class="p">]])</span>
<span class="n">update_manager</span><span class="p">.</span><span class="nf">to_sql</span>
<span class="c1"># =&gt; UPDATE "users" SET "name" = 'Bob', "admin" = 't' WHERE "users"."id" = 42</span>
</code></pre> <h2>The story of <code>.to_sql</code></h2> <p>Throughout the article we&rsquo;ve been calling <code>.to_sql</code> in almost every example and never actually talked about how it works. As mentioned in the beginning, Arel internally represents all queries as nodes in an abstract syntax tree. The managers create and modify these trees. Naturally, something later has to take the resulting tree and process it to the final output. Arel uses various kinds of visitors to accomplish this (see the <a href="//en.wikipedia.org/wiki/Visitor_pattern">Visitor pattern</a>). </p> <p>In essence, the visitor pattern abstracts away how the nodes of an AST are processed from the nodes themselves. The nodes stay the same, yet it&rsquo;s possible to apply different visitors and get different results. This is exactly what Arel needs to generate all those kinds of output formats.</p> <p>The Arel&rsquo;s implementation of the visitor pattern is interesting. It uses a variation called <a href="//web.info.uvt.ro/~oaritoni/inginerie/Cursuri/DesignPatterns/L7/Visitor/nordberg.ps.pdf">Extrinsic Visitor</a>. The variation takes great advantage of Ruby&rsquo;s dynamic behavior and the information available at runtime. Instead of forcing the nodes to implement the <code>accept</code> method, the visitor calls <a href="https://github.com/rails/arel/blob/f50de54/lib/arel/visitors/visitor.rb#L4-6">accept</a> on itself with the root node as argument. It then inspects the node to find out its type and <a href="https://github.com/rails/arel/blob/f50de54/lib/arel/visitors/visitor.rb#L21-31">looks</a> the appropriate visit method. To make the dispatching part faster, the code uses a simple <a href="https://github.com/rails/arel/blob/f50de54/lib/arel/visitors/visitor.rb#L10-L15">hash table</a> for caching purposes.</p> <pre><code class="highlight ruby"><span class="p">{</span> 
  <span class="no">Arel</span><span class="o">::</span><span class="no">Visitors</span><span class="o">::</span><span class="no">SQLite</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="no">Arel</span><span class="o">::</span><span class="no">Nodes</span><span class="o">::</span><span class="no">SelectStatement</span> <span class="o">=&gt;</span> <span class="s2">"visit_Arel_Nodes_SelectStatement"</span><span class="p">,</span>
    <span class="no">Arel</span><span class="o">::</span><span class="no">Nodes</span><span class="o">::</span><span class="no">SqlLiteral</span>      <span class="o">=&gt;</span> <span class="s2">"visit_Arel_Nodes_SqlLiteral"</span><span class="p">,</span>
    <span class="no">Arel</span><span class="o">::</span><span class="no">Nodes</span><span class="o">::</span><span class="no">Or</span>              <span class="o">=&gt;</span> <span class="s2">"visit_Arel_Nodes_Or"</span><span class="p">,</span>
    <span class="no">Arel</span><span class="o">::</span><span class="no">Attributes</span><span class="o">::</span><span class="no">Attribute</span>  <span class="o">=&gt;</span> <span class="s2">"visit_Arel_Attributes_Attribute"</span><span class="p">,</span>
    <span class="no">Arel</span><span class="o">::</span><span class="no">Nodes</span><span class="o">::</span><span class="no">InnerJoin</span>       <span class="o">=&gt;</span> <span class="s2">"visit_Arel_Nodes_InnerJoin"</span><span class="p">,</span>
    <span class="no">Arel</span><span class="o">::</span><span class="no">Nodes</span><span class="o">::</span><span class="no">Having</span>          <span class="o">=&gt;</span> <span class="s2">"visit_Arel_Nodes_Having"</span><span class="p">,</span>
    <span class="no">Arel</span><span class="o">::</span><span class="no">Nodes</span><span class="o">::</span><span class="no">Limit</span>           <span class="o">=&gt;</span> <span class="s2">"visit_Arel_Nodes_Limit"</span>
    <span class="no">Fixnum</span>                       <span class="o">=&gt;</span> <span class="s2">"visit_Fixnum"</span><span class="p">,</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre> <p>If we look into the <a href="https://github.com/rails/arel/tree/f50de54/lib/arel/visitors">visitors directory</a>, we can see a few visitors that Arel comes with by default. Some of them directly correspond to a particular database, some are used only internally and some are used only from AR. Notice that all database related visitors inherit from the <a href="https://github.com/rails/arel/blob/f50de54/lib/arel/visitors/to_sql.rb">to_sql</a> visitor, which is doing most of the work, and that the particular database visitor handles only the differences specific to the concrete database. Let&rsquo;s create a select manager and get the SQL query out of it without the <code>to_sql</code> method.</p> <pre><code class="highlight ruby"><span class="n">select_manager</span> <span class="o">=</span> <span class="n">users</span><span class="p">.</span><span class="nf">project</span><span class="p">(</span><span class="no">Arel</span><span class="p">.</span><span class="nf">star</span><span class="p">)</span>
<span class="n">select_manager</span><span class="p">.</span><span class="nf">to_sql</span>
<span class="c1"># =&gt; SELECT * FROM "users"</span>

<span class="n">sqlite_visitor</span> <span class="o">=</span> <span class="no">Arel</span><span class="o">::</span><span class="no">Visitors</span><span class="o">::</span><span class="no">SQLite</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">.</span><span class="nf">connection</span><span class="p">)</span>
<span class="n">collector</span>      <span class="o">=</span> <span class="no">Arel</span><span class="o">::</span><span class="no">Collectors</span><span class="o">::</span><span class="no">SQLString</span><span class="p">.</span><span class="nf">new</span>
<span class="n">collector</span>      <span class="o">=</span> <span class="n">sqlite_visitor</span><span class="p">.</span><span class="nf">accept</span><span class="p">(</span><span class="n">select_manager</span><span class="p">.</span><span class="nf">ast</span><span class="p">,</span> <span class="n">collector</span><span class="p">)</span>
<span class="n">collector</span><span class="p">.</span><span class="nf">value</span>
<span class="c1"># =&gt; SELECT * FROM "users"</span>
</code></pre> <p>A collector is an object that gathers the results as they come in from the visitor. In this particular example, <code>collector</code> could have been a Ruby&rsquo;s own String and we&rsquo;d get the same result (without calling the final <code>value</code> of course). If we look at the actual <a href="https://github.com/rails/arel/blob/f50de54/lib/arel/tree_manager.rb#L27-L31">source code</a> of <code>to_sql</code>, we can see that it does the same except it gets the visitor directly from the connection. </p> <p>Let&rsquo;s take a look at one more visitor, <a href="https://github.com/rails/arel/blob/f50de54/lib/arel/visitors/dot.rb">Arel::Visitors::Dot</a>. The visitor generates the Graphviz&rsquo;s Dot format and we can use it to create diagrams out of an AST. To make things easier, there&rsquo;s a convenient <a href="https://github.com/rails/arel/blob/f50de54/lib/arel/tree_manager.rb#L17-L19">to_dot</a> method we can use. We take the output and save it to a file. </p> <pre><code class="highlight ruby"><span class="no">File</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="s2">"arel.dot"</span><span class="p">,</span> <span class="n">select_manager</span><span class="p">.</span><span class="nf">to_dot</span><span class="p">)</span>
</code></pre> <p>On the command line, we use the <code>dot</code> utility to convert the result to an image.</p> <pre><code class="highlight shell">dot arel.dot -T png -o arel.png
</code></pre> <div class=image> <a href="/images/arel/arel_to_dot-1af28ad9.png"> <img src="/images/arel/arel_to_dot_small-1e03547a.png" title=fu /> </a> </div> <h2>Back to upper levels</h2> <p>We have all this power at our disposal at the Arel level but how can we leverage it with ActiveRecord? Turns out that we can very easily get the underlying <code>Arel::Table</code> directly from our models with <code>&lt;Table&gt;.arel_table</code>. What&rsquo;s even better is that we can get the AST from our ActiveRecord&rsquo;s queries and manipulate it. A word of warning though, working with the underlying Arel object is not officially supported and things may change between releases without notice.</p> <p>First, we need a few throw-away tables and the corresponding ActiveRecord objects to work against. Let&rsquo;s go again with users and comments.</p> <pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">connection</span><span class="p">.</span><span class="nf">create_table</span> <span class="n">table_name</span><span class="p">,</span> <span class="ss">force: </span><span class="kp">true</span> <span class="k">do</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span>
    <span class="n">t</span><span class="p">.</span><span class="nf">string</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">null: </span><span class="kp">false</span>
    <span class="n">t</span><span class="p">.</span><span class="nf">integer</span> <span class="ss">:karma</span><span class="p">,</span> <span class="ss">null: </span><span class="kp">false</span><span class="p">,</span> <span class="ss">default: </span><span class="mi">0</span>
    <span class="n">t</span><span class="p">.</span><span class="nf">boolean</span> <span class="ss">:vip</span><span class="p">,</span> <span class="ss">null: </span><span class="kp">false</span><span class="p">,</span> <span class="ss">default: </span><span class="kp">false</span>
    <span class="n">t</span><span class="p">.</span><span class="nf">timestamps</span>
  <span class="k">end</span>

  <span class="n">create!</span> <span class="p">[{</span><span class="nb">name</span><span class="p">:</span> <span class="s2">"Alice"</span><span class="p">,</span> <span class="ss">karma: </span><span class="mi">999</span><span class="p">,</span> <span class="ss">vip: </span><span class="kp">true</span><span class="p">},</span> <span class="p">{</span><span class="nb">name</span><span class="p">:</span> <span class="s2">"Bob"</span><span class="p">,</span> <span class="ss">karma: </span><span class="mi">1000</span><span class="p">},</span> <span class="p">{</span><span class="nb">name</span><span class="p">:</span> <span class="s2">"Charlie"</span><span class="p">}]</span>

  <span class="n">has_many</span> <span class="ss">:comments</span><span class="p">,</span> <span class="ss">dependent: :delete_all</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Comment</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">connection</span><span class="p">.</span><span class="nf">create_table</span> <span class="n">table_name</span><span class="p">,</span> <span class="ss">force: </span><span class="kp">true</span> <span class="k">do</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span>
    <span class="n">t</span><span class="p">.</span><span class="nf">text</span> <span class="ss">:text</span><span class="p">,</span> <span class="ss">null: </span><span class="kp">false</span>
    <span class="n">t</span><span class="p">.</span><span class="nf">integer</span> <span class="ss">:points</span><span class="p">,</span> <span class="ss">null: </span><span class="kp">false</span><span class="p">,</span> <span class="ss">default: </span><span class="mi">0</span>
    <span class="n">t</span><span class="p">.</span><span class="nf">references</span> <span class="ss">:user</span>
    <span class="n">t</span><span class="p">.</span><span class="nf">timestamps</span>
  <span class="k">end</span>

  <span class="n">belongs_to</span> <span class="ss">:user</span>
<span class="k">end</span>
</code></pre> <p>As mentioned in the previous paragraph, we can get the <code>Arel::Table</code> object out by calling <a href="https://github.com/rails/rails/blob/178448/activerecord/lib/active_record/core.rb#L216-L218">arel_table</a> on the model. Once we do that, we can use the same methods as we&rsquo;ve been using so far throughout the text.</p> <pre><code class="highlight ruby"><span class="n">u</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">arel_table</span>
<span class="no">User</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="ss">:karma</span><span class="p">].</span><span class="nf">gteq</span><span class="p">(</span><span class="mi">1000</span><span class="p">).</span><span class="nf">or</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="ss">:vip</span><span class="p">].</span><span class="nf">eq</span><span class="p">(</span><span class="kp">true</span><span class="p">))).</span><span class="nf">to_a</span>
<span class="c1"># =&gt; [#&lt;User id: 1, name: "Alice"...&gt;, #&lt;User id: 2, name: "Bob"...&gt;]</span>
</code></pre> <p>Here we&rsquo;re passing an Arel node (<code>Arel::Nodes::Grouping</code>) directly to AR&rsquo;s <code>where</code>. No need to convert anything as AR knows how to deal with these objects. Let&rsquo;s switch the sides and use an AR query inside an Arel one.</p> <pre><code class="highlight ruby"><span class="no">User</span><span class="p">.</span><span class="nf">first</span><span class="p">.</span><span class="nf">comments</span><span class="p">.</span><span class="nf">create!</span> <span class="ss">text: </span><span class="s2">"Sample text!"</span><span class="p">,</span> <span class="ss">points: </span><span class="mi">1001</span>

<span class="n">c</span>             <span class="o">=</span> <span class="no">Comment</span><span class="p">.</span><span class="nf">arel_table</span>
<span class="n">popular_users</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="ss">:id</span><span class="p">).</span><span class="nf">order</span><span class="p">(</span><span class="ss">karma: :desc</span><span class="p">).</span><span class="nf">limit</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">comments</span>      <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="nf">project</span><span class="p">(</span><span class="no">Arel</span><span class="p">.</span><span class="nf">star</span><span class="p">).</span><span class="nf">where</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="ss">:points</span><span class="p">].</span><span class="nf">gt</span><span class="p">(</span><span class="mi">1000</span><span class="p">).</span><span class="nf">and</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="ss">:user_id</span><span class="p">].</span><span class="nf">in</span><span class="p">(</span><span class="n">popular_users</span><span class="p">.</span><span class="nf">ast</span><span class="p">)))</span>

<span class="no">Comment</span><span class="p">.</span><span class="nf">find_by_sql</span><span class="p">(</span><span class="n">comments</span><span class="p">.</span><span class="nf">to_sql</span><span class="p">)</span>
</code></pre> <p>To execute Arel queries, we first need to get the SQL out of Arel and then feed it into <a href="https://github.com/rails/rails/blob/178448/activerecord/lib/active_record/querying.rb#L38-L49">find_by_sql</a>. Notice that we called <code>ast</code> on <code>popular_users</code> before passing it to Arel&rsquo;s <code>in</code>. That&rsquo;s because <code>popular_users</code> is an instance of <code>ActiveRecord::Relation</code> and we need to get the underlying Arel AST. </p> <p>There of course comes a time when you need to issue a query that doesn&rsquo;t necessarily result in records coming back. In that case, we can use the connection directly and call <code>execute</code> with the SQL as the argument.</p> <pre><code class="highlight ruby"><span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">.</span><span class="nf">connection</span><span class="p">.</span><span class="nf">execute</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="ss">:id</span><span class="p">].</span><span class="nf">eq</span><span class="p">(</span><span class="mi">1</span><span class="p">)).</span><span class="nf">compile_delete</span><span class="p">.</span><span class="nf">to_sql</span><span class="p">)</span>
</code></pre> <p>One issue you may run into when using ActiveRecord 4.1.x is that calling <code>to_sql</code> might return an SQL query with bind parameters instead of the actual values. The issue has been solved on the current master branch and will be part of the next release. To get around that issue now however, we must use <code>unprepared_statement</code>.</p> <pre><code class="highlight ruby"><span class="c1"># ActiveRecord 4.1.x</span>

<span class="n">sql</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">first</span><span class="p">.</span><span class="nf">comments</span><span class="p">.</span><span class="nf">to_sql</span>
<span class="c1"># =&gt; SELECT "comments".* FROM "comments"  WHERE "comments"."user_id" = ?</span>

<span class="n">sql</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">connection</span><span class="p">.</span><span class="nf">unprepared_statement</span> <span class="p">{</span> 
  <span class="no">User</span><span class="p">.</span><span class="nf">first</span><span class="p">.</span><span class="nf">comments</span><span class="p">.</span><span class="nf">to_sql</span> 
<span class="p">}</span>
<span class="c1"># =&gt; SELECT "comments".* FROM "comments"  WHERE "comments"."user_id" = 1</span>
</code></pre> <p>The code in the <code>unprepared_statement</code> block gets evaluated with a visitor that mixes in <a href="https://github.com/rails/arel/blob/f50de54/lib/arel/visitors/bind_visitor.rb">Arel::Visitors::BindVisitor</a>, which immediately resolves the bind parameters.</p> <h2>Real world</h2> <p>Having covered all of that, how do we use this in a real word application so that the code is maintainable and won&rsquo;t become a mess? One way of doing it is to create a class that will represent our query. Let&rsquo;s take a look at a simple example.</p> <pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">PrivilegedUsersQuery</span>
  <span class="kp">attr_reader</span> <span class="ss">:relation</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">relation</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">all</span><span class="p">)</span>
    <span class="vi">@relation</span> <span class="o">=</span> <span class="n">relation</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">find_each</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
    <span class="n">relation</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="n">privileged_users</span><span class="p">).</span><span class="nf">find_each</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="kp">private</span>

  <span class="k">def</span> <span class="nf">privileged_users</span>
    <span class="n">with_high_karma</span><span class="p">.</span><span class="nf">or</span> <span class="n">with_vip</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">with_high_karma</span>
    <span class="n">table</span><span class="p">[</span><span class="ss">:karma</span><span class="p">].</span><span class="nf">gt</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">with_vip</span>
    <span class="n">table</span><span class="p">[</span><span class="ss">:vip</span><span class="p">].</span><span class="nf">eq</span><span class="p">(</span><span class="kp">true</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">table</span>
    <span class="no">User</span><span class="p">.</span><span class="nf">arel_table</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre> <p>We take full advantage of the fact that we can build queries iteratively and dedicate a method to each part or similar, whatever feels like the best approach for the particular situation.</p> <pre><code class="highlight ruby"><span class="no">PrivilegedUsersQuery</span><span class="p">.</span><span class="nf">new</span><span class="p">.</span><span class="nf">find_each</span> <span class="k">do</span> <span class="o">|</span><span class="n">user</span><span class="o">|</span> 
 <span class="c1"># ...</span>
<span class="k">end</span>
</code></pre> <h2>The end</h2> <p><a href="https://github.com/rails/arel">Arel</a> is a great tool to build abstractions upon and a powerful helper when the abstractions fail to provide the functionality you need. By now you know everything there&rsquo;s to know to use Arel effectively and most importantly you know where to look for answers when constructing a complicated query or when things go wrong. Please let me know if you found an error of any kind or have other suggestions.</p> <h1><a href="/2014/03/16/replacing-make-with-ninja.html">Replacing Make with Ninja</a></h1><div class=published>Published on Mar 16, 2014</div><p>Make and all of its flavours have been here for almost 40 years and it&rsquo;s a tool hard to beat for many things. There are however cases when you do not need the power of Make and are willing to trade the flexibility for something else. In case of <a href="//martine.github.io/ninja">Ninja</a>, for its speed.</p> <p>Speed is the main motivation behind Ninja and its decisions how to write your build files. Ninja was written by <a href="//neugierig.org">Evan Martin</a> specifically to fight slow build cycles while working on Google Chrome. </p> <p>The bigger the project, the longer it takes to figure out what files need to be recompiled or if any action is required at all. As a result of numerous optimizations, Ninja is much faster when compared to alternatives. Ninja&rsquo;s secret is to do the least amount of work possible and let other more high level tools to handle the rest upfront. </p> <p>Let&rsquo;s see an example of a simple script featuring all of the abstractions Ninja provides:</p> <pre><code class="highlight shell"><span class="c"># build.ninja</span>
cc     <span class="o">=</span> clang
cflags <span class="o">=</span> -Weverything

rule compile
  <span class="nb">command</span> <span class="o">=</span> <span class="nv">$cc</span> <span class="nv">$cflags</span> -c <span class="nv">$in</span> -o <span class="nv">$out</span>

rule link
  <span class="nb">command</span> <span class="o">=</span> <span class="nv">$cc</span> <span class="nv">$in</span> -o <span class="nv">$out</span>

build hello.o: compile hello.c
build hello: link hello.o

default hello
</code></pre> <p>Putting aside the fact that there&rsquo;s no point in writing something like this for a single file, let&rsquo;s see what&rsquo;s going on there. First, we define 2 variables and later refer to them using the <code>$</code> sign. Second, there are rules. Rules are essentially functions that call an external command to perform an action. Finally, build statements are used to define dependencies between input and output files. If you were to write the same with Make using its conventions, you&rsquo;d probably end up with something like <a href="https://gist.github.com/mekishizufu/5f0750989c2cefc0e257">this</a>.</p> <p>To see a more realistic example with proper dependency tracking, I converted <a href="//libgit2.github.com">libgit2</a>&rsquo;s <a href="https://github.com/libgit2/libgit2/blob/2b403/Makefile.embed">Makefile.embed</a> to Ninja. The Makefile compiles libgit2 and creates a static library out of it. You can see the result <a href="https://gist.github.com/mekishizufu/1d099dda373280206aee">here</a>.</p> <p>You&rsquo;ve probably noticed a few things. First, Ninja scripts are explicit. You cannot use any fancy substitution/wildcard functions (or any other control structures for that matter). As a result, the script is not only much longer but it also cannot handle any conditions making it unsuitable to any multi platform/compiler development. And this is by design.</p> <p>I&rsquo;ve mentioned that Ninja is meant to be used with a higher level tool (generator). One of the reasons for doing that is to overcome the said issues. In practice this means that you do not care about the absence of conditions or any other capabilities because the generator handles it for you simply by generating a different set of build scripts.</p> <p>Ninja comes with a simple <a href="https://github.com/martine/ninja/blob/84986/misc/ninja_syntax.py">Python based generator</a>. The generator is straightforward, you call the methods and it outputs the corresponding Ninja syntax to a file. Since it&rsquo;s just Python, you can make all of the platform and compiler decisions here. In fact, this is the way Ninja itself is <a href="https://github.com/martine/ninja/blob/84986/configure.py">built</a>:</p> <pre><code class="highlight python"><span class="kn">from</span> <span class="nn">ninja_syntax</span> <span class="kn">import</span> <span class="n">Writer</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">"build.ninja"</span><span class="p">,</span> <span class="s">"w"</span><span class="p">)</span> <span class="k">as</span> <span class="n">buildfile</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">Writer</span><span class="p">(</span><span class="n">buildfile</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">platform</span><span class="o">.</span><span class="n">is_msvc</span><span class="p">():</span>
        <span class="n">n</span><span class="o">.</span><span class="n">rule</span><span class="p">(</span><span class="s">"link"</span><span class="p">,</span>
                <span class="n">command</span><span class="o">=</span><span class="s">"$cxx $in $libs /nologo /link $ldflags /out:$out"</span><span class="p">,</span>
                <span class="n">description</span><span class="o">=</span><span class="s">"LINK $out"</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n</span><span class="o">.</span><span class="n">rule</span><span class="p">(</span><span class="s">"link"</span><span class="p">,</span>
                <span class="n">command</span><span class="o">=</span><span class="s">"$cxx $ldflags -o $out $in $libs"</span><span class="p">,</span>
                <span class="n">description</span><span class="o">=</span><span class="s">"LINK $out"</span><span class="p">)</span>
</code></pre> <p>The fun part is that Ninja is already supported by some of the most popular meta build systems out there - <a href="//www.cmake.org">CMake</a> and <a href="https://code.google.com/p/gyp">Gyp</a>. If you have a CMake based project and assuming you have Ninja available in your PATH, all you need to do is to choose Ninja as the <a href="//www.cmake.org/cmake/help/v2.8.12/cmake.html#section_Generators">generator</a>:</p> <pre><code class="highlight shell"><span class="gp">$ </span><span class="nb">cd </span>libgit2 <span class="o">&amp;&amp;</span> mkdir build <span class="o">&amp;&amp;</span> <span class="nb">cd </span>build
<span class="gp">$ </span>cmake -GNinja ..
<span class="gp">$ </span>ninja
</code></pre> <p>With this change, CMake generates a bunch of Ninja build files and Ninja builds the project. Notice that there&rsquo;s no need to specify the number of parallel jobs (<code>-j [jobs]</code>) because Ninja automatically chooses the value based on the number of cores available. </p> <p>The compilation speed is not very different although it might be a bit faster due to Ninja consuming very little CPU while driving the build process. What is however very significant are the time savings when working with the source code and invoking the build process again. A non-scientific benchmark performed on my laptop shows that Ninja is indeed much faster:</p> <table class="table table-hover"> <thead> <th></th> <th></th> <th>No file changes</th> <th>1 file change</th> </thead> <tbody> <tr> <td></td> <td><strong>Make</strong></td> <td>0.670s</td> <td>2.404s</td> </tr> <tr> <td></td> <td><strong>Ninja</strong></td> <td>0.041s</td> <td>0.761s</td> </tr> </tbody> </table> <p>These savings will become even more significant as your project grows. I encourage you to try <a href="https://github.com/martine/ninja">Ninja</a> and compare the build cycle times with Make. You will very likely see a similar difference. If you want to learn more about Ninja, here&rsquo;s a few links:</p> <ul> <li><a href="//martine.github.io/ninja">Ninja, a small build system with a focus on speed</a> (homepage)</li> <li><a href="//www.aosabook.org/en/posa/ninja.html">The Performance of Open Source Software | Ninja</a></li> <li><a href="//neugierig.org/software/chromium/notes/2011/02/ninja.html">Ninja, a new build system</a></li> </ul> <div class=visible-xs><hr/><h5>Recent articles</h5><ul><li><a href="/2014/06/16/the-definitive-guide-to-arel-the-sql-manager-for-ruby.html">The definitive guide to Arel, the SQL manager for Ruby</a></li><li><a href="/2014/03/16/replacing-make-with-ninja.html">Replacing Make with Ninja</a></li></ul></div><footer><p>&copy; Copyright 2014, Jiří Pospíšil</p></footer></div></div></div><script>window._gaq = window._gaq || [];
window._gaq.push(['_setAccount', 'UA-36750151-1']);
window._gaq.push(['_trackPageview']);

(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();</script></body></html>