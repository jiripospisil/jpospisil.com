<!DOCTYPE html>
<html>
    <head>
        
        <meta charset="utf-8">
<link rel="preload" crossorigin="anonymous" href="/fonts/Inter-Regular.woff2?v=3.19" as="font">
<link rel="preload" crossorigin="anonymous" href="/fonts/Inter-Light.woff2?v=3.19" as="font">
<link rel="preload" crossorigin="anonymous" href="/fonts/Inter-Bold.woff2?v=3.19" as="font">
<link rel="preload" crossorigin="anonymous" href="/fonts/Inter-SemiBold.woff2?v=3.19" as="font">
<link rel="preload" crossorigin="anonymous" href="/css/default.css" as="style">
<link rel="preload" crossorigin="anonymous" href="/css/post.css" as="style">

<link rel="stylesheet" crossorigin="anonymous" href="/css/post.css">
<link rel="icon" crossorigin="anonymous" href="/images/favicon.png">
<title>
            Understanding lock files in NPM 5 - Jiri Pospisil
        </title>

    </head>

    <body>
        <div class="container">
            <h1><a href="/2017/06/02/understanding-lock-files-in-npm-5.html">Understanding lock files in NPM 5</a></h1>

            <div class="topbar">
                <a href="/"><img class="logo" height="30px" src="/images/logo.jpg"></a>
                <div class="name"><a href="/">Jiri Pospisil</a></div>
    			<span class="published">Published Jun 02, 2017</span>
            </div>

            <p>The next major version of NPM brings a number of improvements over the previous
versions in terms of speed, security, and a bunch of other <a href="https://blog.npmjs.org/post/161276872334/npm5-is-now-npmlatest">nifty
things</a>. What
stands out from the user's perspective however is the new lock file. Actually
lock <em>files</em>. More on that in a second. For the uninitiated, a <code>package.json</code>
file describes the top level dependencies on other packages using
<a href="https://semver.org/">semver</a>. </p>
<p>Each package might in turn depend on other packages and so on and so forth. A lock 
file is a snapshot of the entire dependency tree and includes all packages and their resolved versions.</p>
<p>As opposed to the previous version, the lock file now includes an integrity
field which uses <a href="https://w3c.github.io/webappsec-subresource-integrity/">Subresource
Integrity</a> to verify
that the installed package has not been tampered with or is otherwise invalid.
It currently supports SHA-1 for packages published with an older version of NPM
and SHA-512 which is used from now on by default.</p>
<p>What the file now <em>doesn't</em> have is the <code>from</code> field which together with the
sometimes inconsistent <code>version</code> has notoriously been a source of pain when
looking at the file's diff during code reviews. It should be much cleaner now. </p>
<p>The file now also contains a version of the lock format specified in
<code>lockfileVersion</code> and set to <code>1</code>. This is to enable future updates of the
format without having to guess what particular version the file uses. The
previous lock format is still supported and recognized as version <code>0</code>.</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;package-name&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;lockfileVersion&quot;: 1,
  &quot;dependencies&quot;: {
    &quot;cacache&quot;: {
      &quot;version&quot;: &quot;9.2.6&quot;,
      &quot;resolved&quot;: &quot;https://registry.npmjs.org/cacache/-/cacache-9.2.6.tgz&quot;,
      &quot;integrity&quot;: &quot;sha512-YK0Z5Np5t755edPL6gfdCeGxtU0rcW/DBhYhYVDckT+7AFkCCtedf2zru5NRbBLFk6e7Agi/RaqTOAfiaipUfg==&quot;
    },
    &quot;duplexify&quot;: {
      &quot;version&quot;: &quot;3.5.0&quot;,
      &quot;resolved&quot;: &quot;https://registry.npmjs.org/duplexify/-/duplexify-3.5.0.tgz&quot;,
      &quot;integrity&quot;: &quot;sha1-GqdzAC4VeEV+nZ1KULDMquvL1gQ=&quot;,
      &quot;dependencies&quot;: {
        &quot;end-of-stream&quot;: {
          &quot;version&quot;: &quot;1.0.0&quot;,
          &quot;resolved&quot;: &quot;https://registry.npmjs.org/end-of-stream/-/end-of-stream-1.0.0.tgz&quot;,
          &quot;integrity&quot;: &quot;sha1-1FlucCc0qT5A6a+GQxnqvZn/Lw4=&quot;
        },
</code></pre>
<p>You might have noticed that the <code>resolved</code> field is still present in the file
pointing to a specific URI. Note however that NPM is now able to figure out
(based on the settings in <code>.npmrc</code>) that the machine is configured to use a
different registry and if so, it will transparently use it instead. This plays
well with the integrity field because it now doesn't matter from where the
package came from as long as it matches the signature.</p>
<p>One more thing worth mentioning is that the lock file precisely describes the
physical tree of directories as laid out in the <code>node_modules</code> directory. The
advantage of that is that even if different developers use a different version
of NPM, they should still end up with not only the same versions of
dependencies but also with the exact same directory tree. This is different
from other package managers such as <a href="https://yarnpkg.com/en/">Yarn</a>. Yarn
describes just the dependencies between the individual packages in a <a href="https://github.com/yarnpkg/yarn/blob/46750b2bebd487fb2d2011b9c4b7646ec6e2d8a3/yarn.lock">flatten
format</a>
and relies on its current implementation to create the directory structure.
This means that if its internal algorithm changes, the structure changes as
well. If you want to know more about the differences between Yarn and NPM 5
when it comes to the lock file, head over to <a href="https://yarnpkg.com/blog/2017/05/31/determinism/">Yarn
determinism</a>.</p>
<h2>Two lock files</h2>
<p>I've mentioned that there's actually more than one lock file now, sort of. NPM
will now <em>automatically</em> generate a lock file called <code>package-lock.json</code>
whenever a new dependency is installed or the file doesn't yet exist. As
mentioned at the beginning, the lock file is a snapshot of the current
dependency tree and allows for reproducible builds between machines. As such,
it's recommended to add it to your version control.</p>
<p>You might be thinking that the same can already be achieved with <code>npm shrinkwrap</code> and its <code>npm-shrinkwrap.json</code>. And you are right. The reasoning for
creating a new file is to better convey the message that NPM indeed supports
locking which apparently has been an issue in the past.</p>
<p>There are however a few differences. First, NPM enforces that
<code>package-lock.json</code> is never published. Even if you add it explicitly to the
package's <code>files</code> property, it will not be a part of the published package. The
same doesn't apply for the <code>npm-shrinkwrap.json</code> file however which <em>can</em> be a
part of a published package and NPM will respect it even for nested
dependencies. It's simple to try it out for yourself by running <code>npm pack</code> and
seeing what's inside of the produced archive.</p>
<p>Next, you might be wondering what happens when you run <code>npm shrinkwrap</code> in a
directory which already contains a <code>package-lock.json</code>. The answer is rather
simple, NPM will just rename <code>package-lock.json</code> to <code>npm-shrinkwrap.json</code>.
That's possible because the format of the files is exactly the same.</p>
<p>The most curious will also ask what happens when both of the files are present.
In that case, NPM will completely ignore <code>package-lock.json</code> and just use
<code>npm-shrinkwrap.json</code>. The situation should not happen however when
manipulating the files just using NPM.</p>
<h3>To summarize:</h3>
<ul>
<li>
<p>NPM will automatically create a <code>package-lock.json</code> when installing packages
unless there's already <code>npm-shrinkwrap.json</code> in which case it will update it
instead (if necessary).</p>
</li>
<li>
<p>The new <code>package-lock.json</code> is never published and should be added to your
version control system.</p>
</li>
<li>
<p>Running <code>npm shrinkwrap</code> with a <code>package-lock.json</code> already present will just
rename it to <code>npm-shrinkwrap.json</code>.</p>
</li>
<li>
<p>When both files are present for some reason, <code>package-lock.json</code> will be
ignored.</p>
</li>
</ul>
<p>That's all cool but when do you use the new lock file instead of the good old
shrinkwrap or vice versa? It generally depends on the type of package you're
working on.</p>
<h2>When working on a library</h2>
<p>If you're working on a library (as in a package onto which others will depend
on), you should use the new lock file. An alternative is to use shrinkwrap but
make sure it never gets published with the package (the new lock file is never
published automatically). Why not publish the shrinkwrap? It's because NPM
respects shrinkwraps it finds within packages and since a shrinkwrap always
points to a specific version of individual packages, you would not take
advantage of the fact that NPM can use the same package to satisfy requirements
from multiple packages if the <a href="https://semver.org">semver</a> range allows it. In
other words, by not forcing NPM to install specific versions, you allow NPM to
better reuse packages across the dependency tree and make the result smaller
and faster to assemble.</p>
<p>There's one caveat to this however. When you're working on your library, you
get the exact same dependencies every time because either <code>package-lock.json</code>
or <code>npm-shrinkwrap.json</code> is present in the repository. The same goes for your
continuous integration server where you check out the same code. Now imagine
your <code>package.json</code> specifies a dependency on some package as <code>^1.0.0</code> and that
also happens to be the version specified in the lock file and installed every
time. Everything works. Now what happens if a new version of the dependency is
published, accidentally breaks semver and your package breaks because of it?</p>
<p>Unfortunately, you might not be able to notice that until a bug report comes
in. Without any lock files in the repository, your build would fail at least on
the CI because it would always install the <code>latest</code> versions of the
dependencies and thus run the tests with the new broken version (provided that
the build is run periodically, not just for PRs). With the lock in place
however, it will always install the working locked version. </p>
<p>There's a couple of solutions to this problem however. First, you could
sacrifice the exact reproducibility and <em>not</em> add the lock file to your version
control system. Second, you could make a separate build configuration which
would run <code>npm update</code> prior running the tests. Third, you simply delete the
lock before running the tests in the special build. How to actually deal with
the broken dependency once discovered is another topic on its own mainly
because semver as implemented by NPM doesn't have a concept of allowing a wide
range but also blacklisting specific versions.</p>
<p>This of course begs the question whether it's actually worth it to add the lock
file into the version control when working on libraries. A thing to keep in
mind however is that the lock file contains not only dependencies but also
<em>dev</em> dependencies. In that sense working on a library is similar to working on
an application (see the next section) and having the exact same dev
dependencies over time and across multiple machines is an advantage.</p>
<h2>When working on an application</h2>
<p>Alright, what about packages used by the end users in the terminal or bundled
executables in general? In this case, the package is the final result, the
application, and you want to make sure that the end users always get the exact
dependencies you had while publishing it. This is where you want to use
shrinkwrap and make sure to also publish it with the package so that it's
respected by NPM during install. Remember, you can always see what the package
would look like if published using <code>npm pack</code>.</p>
<p>Note that pointing to a specific version of a dependency in <code>package.json</code> is
not good enough because you want to make sure the end users get the <em>exact</em>
same dependency tree including all of its sub-dependencies. A specific version
in <code>package.json</code> guarantees the version only at the top level.</p>
<p>What about other types of applications, for example projects you start from
within their repository? It doesn't really matter that much in this case. All
that matters is that the correct dependencies are installed and both of the
locks can satisfy that. Your choice.</p>
<h2>That's a wrap</h2>
<p>And that about wraps it up for now. Feel free to reach out on Twitter if
something's not right or with some general suggestions. If you've found a typo
or some other grammar issue, the blog post is available on
<a href="https://github.com/jiripospisil/jpospisil.com">GitHub</a>. Any help is
appreciated!</p>


            <p class="back"><a href="/">Go back to the front page</a></p>
        </div>
  </body>
</html>
