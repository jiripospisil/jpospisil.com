<!DOCTYPE html><html><head><title>The definitive guide to Arel, the SQL manager for Ruby - Jiří Pospíšil's blog</title><meta charset=utf-8 /><meta content="width=device-width, initial-scale=1" name=viewport /><link href="//cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.1.1/css/bootstrap.min.css" rel=stylesheet /><link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.0.3/css/font-awesome.min.css" rel=stylesheet /><link href="/stylesheets/application-b387a8f1.css" rel=stylesheet /><link href="/images/favicon.ico" rel="shortcut icon" type="image/vnd.microsoft.icon"/><link href="/feed.xml" rel=alternate title="Jiří Pospíšil's blog - Atom Feed" type="application/atom+xml"/></head><body><div class=container><div class=row><div class=col-sm-12><div class=avatar><a href="/"><img height=150px src="/images/avatar-c0869a08.jpg" width=150px /></a></div><div class=text-center><h1>Jiří Pospíšil</h1><div class=icons><a href="https://twitter.com/JiriPospisil"><i class="fa fa-twitter"></i></a><a href="https://github.com/jiripospisil"><i class="fa fa-github"></i></a><a href="//stackoverflow.com/users/19093/jiri-pospisil"><i class="fa fa-stack-overflow"></i></a><a href="//jpospisil.com/feed.xml"><i class="fa fa-rss-square"></i></a></div></div></div></div><div class=row><div class=col-sm-12><h1><a href="/2014/06/16/the-definitive-guide-to-arel-the-sql-manager-for-ruby.html">The definitive guide to Arel, the SQL manager for Ruby</a></h1><div class=published>Published on Jun 16, 2014</div><p>Arel is the kind of library that many of us Rails developers use on a daily basis and might not even know about it. So what&rsquo;s this library whose name only pops up when everything else fails all about?</p> <p>It&rsquo;s all about providing frameworks with a way of building and representing SQL queries. It&rsquo;s not the kind of library you would <em>typically</em> want to use directly (although you could as shown in a minute). Arel is meant to be the basic building block upon which frameworks build their own APIs that are more suitable for the end user.</p> <p>One of those frameworks is ActiveRecord (AR), the default ORM in Rails. ActiveRecord&rsquo;s responsibility is to provide a connection to the database, a convenient way to specify relationships between your models, provide a nice query interface and all the other things we enjoy.</p> <p></p> <pre class="highlight ruby"><code><span class="c1"># ActiveRecord</span>
<span class="no">User</span><span class="p">.</span><span class="nf">first</span><span class="p">.</span><span class="nf">comments</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">created_at: </span><span class="mi">2</span><span class="p">.</span><span class="nf">days</span><span class="p">.</span><span class="nf">ago</span><span class="p">.</span><span class="nf">.</span><span class="no">Time</span><span class="p">.</span><span class="nf">current</span><span class="p">).</span><span class="nf">limit</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</code></pre> <p>Behind the scenes, ActiveRecord uses Arel to build the queries and ultimately calls out to it to get the final SQL before shipping it to the database of your choice.</p> <p>So how exactly Arel achieves building the queries in such a flexible way? By building an <a href="//en.wikipedia.org/wiki/Abstract_syntax_tree">AST</a>. Arel internally operates on AST nodes - you modify the query via a method call, Arel modifies or creates the appropriate node in the tree.</p> <div class=image> <img src="/images/arel/ast-02c47682.png" width=347px height=159px title="An select query represented via AST"/> </div> <p>This kind of representation holds two important properties. First, composability. By being composable you gain the power to build the query iteratively, piece by piece, and even combine several queries together. Many parts of the API (and consequently AR&rsquo;s API) would be impossible or at least very difficult handle without this property.</p> <pre class="highlight ruby"><code><span class="c1"># ActiveRecord</span>

<span class="n">bob</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">email: </span><span class="s2">"bob@test.com"</span><span class="p">).</span><span class="nf">where</span><span class="p">(</span><span class="ss">active: </span><span class="kp">true</span><span class="p">)</span>
<span class="c1"># =&gt; SELECT "users".* FROM "users" WHERE "users"."email" = 'bob@test.com' AND "users"."active" = 't'</span>

<span class="n">details</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="ss">:id</span><span class="p">,</span> <span class="ss">:email</span><span class="p">,</span> <span class="ss">:first_name</span><span class="p">).</span><span class="nf">order</span><span class="p">(</span><span class="ss">id: :desc</span><span class="p">)</span>
<span class="c1"># =&gt; SELECT "users"."id", "users"."email", "users"."first_name" FROM "users" ORDER BY "users"."id" DESC</span>

<span class="n">bob</span><span class="p">.</span><span class="nf">merge</span><span class="p">(</span><span class="n">details</span><span class="p">).</span><span class="nf">first</span>
<span class="c1"># =&gt; SELECT "users"."id", "users"."email", "users"."first_name" FROM "users"</span>
<span class="c1">#    WHERE "users"."email" = 'bob@test.com' AND "users"."active" = 't'</span>
<span class="c1">#    ORDER BY "users"."id" DESC LIMIT 1</span>
</code></pre> <p>While a contrived example, it is sufficient to show that it&rsquo;d be very difficult to work with these queries without some sort of abstract representation.</p> <p>The other equally important property is the completely obliviousness to the outside world. Arel doesn&rsquo;t care what&rsquo;s going to happen with the result. It might end up converted into a SQL query or into an entirely different format. In fact, Arel is able to convert the query into the Graphviz&rsquo;s dot format and you can create pretty diagrams out of it (more on that later).</p> <div class=image> <img src="/images/arel/arel_to_formats-ea4ad339.png" width=356px height=96px title="Arel converted to other formats"/> </div> <p>So far we&rsquo;ve seen only <a href="//guides.rubyonrails.org/active_record_querying.html">ActiveRecord&rsquo;s query interface</a>, the part built on top of Arel. Let&rsquo;s get below the surface and start working with Arel directly. To play along, use the following instructions. The script will download the correct version of libraries and leave you inside a Pry REPL instance (run <code>bundle console</code> if you&rsquo;ve left the REPL and want to come back). It&rsquo;s always a good idea to inspect all 3rd party scripts before you run them.</p> <pre class="highlight shell"><code><span class="nb">cd</span> /tmp
mkdir arel_playground <span class="o">&amp;&amp;</span> <span class="nb">cd </span>arel_playground

wget http://jpospisil.com/arel_setup.sh
<span class="c"># or</span>
curl -L -o arel_setup.sh http://jpospisil.com/arel_setup.sh

bash ./arel_setup.sh
</code></pre> <p>To stay current for the foreseeable future, the text is based on soon-to-be released version of Arel. The text also contains a lot of links to the actual Arel&rsquo;s source code, you are strongly encouraged to look around the file beyond the highlighted area to see all of the options!</p> <h2>Diving in with SelectManager</h2> <p>Let&rsquo;s start by building a select query that will give us all users. First, we need to create an object representing the table itself. Notice that you can name the table whatever you want, it doesn&rsquo;t have to exist anywhere.</p> <pre class="highlight ruby"><code><span class="n">users</span> <span class="o">=</span> <span class="no">Arel</span><span class="o">::</span><span class="no">Table</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:users</span><span class="p">)</span>
</code></pre> <p><code>Arel::Table</code> itself doesn&rsquo;t do much but it has <a href="https://github.com/rails/arel/blob/f50de54/lib/arel/table.rb#L45-L97">a lot of handy methods</a> which are responsible for delegating the calls deeper into the system. The method we are interested in now is the <a href="https://github.com/rails/arel/blob/f50de54/lib/arel/table.rb#L83-85">project</a> method. The name comes from <a href="//en.wikipedia.org/wiki/Projection_(relational_algebra)">relational algebra</a> but rest assured, it&rsquo;s just a plain <code>select</code>.</p> <pre class="highlight ruby"><code><span class="n">select_manager</span> <span class="o">=</span> <span class="n">users</span><span class="p">.</span><span class="nf">project</span><span class="p">(</span><span class="no">Arel</span><span class="p">.</span><span class="nf">star</span><span class="p">)</span>
</code></pre> <p>Notice the use of <a href="https://github.com/rails/arel/blob/f50de54/lib/arel.rb#L30-32">Arel.star</a>, a convenience method for the <code>*</code> character. What we got back is an instance of <a href="https://github.com/rails/arel/blob/f50de54/lib/arel/select_manager.rb">Arel::SelectManager</a>, the object responsible for assembling of the select query. Now we should be able to get the resulting SQL from <code>select_manager</code>.</p> <pre class="highlight ruby"><code><span class="n">select_manager</span><span class="p">.</span><span class="nf">to_sql</span>
<span class="c1"># =&gt; NoMethodError: undefined method `connection' for nil:NilClass</span>
</code></pre> <p>And it didn&rsquo;t work. If you think about it, the failure kind of makes sense (although the error should be handled more gracefully) because we didn&rsquo;t specified any database details and Arel has no way of knowing for what database we want the query generated. Databases may differ in syntax, capabilities and even in character escaping. Let&rsquo;s get ourselves an ActiveRecord database connection and try again.</p> <pre class="highlight ruby"><code><span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">.</span><span class="nf">establish_connection</span><span class="p">(</span><span class="ss">adapter: </span><span class="s2">"sqlite3"</span><span class="p">,</span> <span class="ss">database: </span><span class="s2">":memory:"</span><span class="p">)</span>

<span class="n">users</span>          <span class="o">=</span> <span class="no">Arel</span><span class="o">::</span><span class="no">Table</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:users</span><span class="p">,</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">)</span>
<span class="n">select_manager</span> <span class="o">=</span> <span class="n">users</span><span class="p">.</span><span class="nf">project</span><span class="p">(</span><span class="no">Arel</span><span class="p">.</span><span class="nf">star</span><span class="p">)</span>

<span class="n">select_manager</span><span class="p">.</span><span class="nf">to_sql</span>
<span class="c1"># =&gt; SELECT * FROM "users"</span>
</code></pre> <p>Notice we passed <code>ActiveRecord::Base</code> to the <code>Arel::Table</code>&rsquo;s constructor. We could have also set it globally via <code>Arel::Table.engine=</code>. With all that in place, we finally have our precious SQL query.</p> <p>The interesting thing is the collaboration between Arel and ActiveRecord. Arel is technically independent from ActiveRecord but it needs to get the database details from somewhere and currently it uses ActiveRecord. More specifically, Arel requires ActiveRecord&rsquo;s APIs. There&rsquo;s even a fake ActiveRecord implementation, <a href="https://github.com/rails/arel/blob/f50de54/test/support/fake_record.rb">FakeRecord</a>, that is <a href="https://github.com/rails/arel/blob/f50de54/test/helper.rb#L6-L7">used</a> to run the Arel&rsquo;s tests. In the past you needed a running MySQL server.</p> <h2>Getting picky</h2> <p>Querying for all users&#39; details is nice but let&rsquo;s be more specific. Say we want to select only the users&#39; ids and names. The key abstraction Arel provides for working with attributes (column names) is <a href="https://github.com/rails/arel/blob/f50de54/lib/arel/attributes/attribute.rb">Arel::Attribute</a>.</p> <p><code>Arel::Attribute</code> represents a single column of an arbitrary name. The easiest way to get a hold of an <code>Arel::Attribute</code> for a table is to use the <a href="https://github.com/rails/arel/blob/f50de54/lib/arel/table.rb#L99-101">Arel::Table#[]</a> method. We can use the result right away in the <code>project</code> method.</p> <pre class="highlight ruby"><code><span class="n">select_manager</span> <span class="o">=</span> <span class="n">users</span><span class="p">.</span><span class="nf">project</span><span class="p">(</span><span class="n">users</span><span class="p">[</span><span class="ss">:id</span><span class="p">],</span> <span class="n">users</span><span class="p">[</span><span class="ss">:name</span><span class="p">])</span>
<span class="n">select_manager</span><span class="p">.</span><span class="nf">to_sql</span>
<span class="c1"># =&gt; SELECT "users"."id", "users"."name" FROM "users</span>
</code></pre> <p>As you&rsquo;ve probably noticed, the class gets included with a bunch of modules which add a lot of functionality. The first module, <a href="https://github.com/rails/arel/blob/f50de54/lib/arel/expressions.rb">Arel::Expressions</a>, adds the common aggregate functions.</p> <pre class="highlight ruby"><code><span class="n">select_manager</span> <span class="o">=</span> <span class="n">users</span><span class="p">.</span><span class="nf">project</span><span class="p">(</span><span class="n">users</span><span class="p">[</span><span class="ss">:comments_count</span><span class="p">].</span><span class="nf">average</span><span class="p">)</span>
<span class="n">select_manager</span><span class="p">.</span><span class="nf">to_sql</span>
<span class="c1"># =&gt; SELECT AVG("users"."comments_count") AS avg_id FROM "users"</span>
</code></pre> <p>The results of these aggregate functions are kept in variables with hardcoded names (<code>avg_id</code> in this case). Fortunately, <a href="https://github.com/rails/arel/blob/f50de54/lib/arel/alias_predication.rb">Arel::AliasPredication</a> comes to our rescue.</p> <pre class="highlight ruby"><code><span class="n">select_manager</span> <span class="o">=</span> <span class="n">users</span><span class="p">.</span><span class="nf">project</span><span class="p">(</span><span class="n">users</span><span class="p">[</span><span class="ss">:vip</span><span class="p">].</span><span class="nf">as</span><span class="p">(</span><span class="s2">"status"</span><span class="p">),</span> <span class="n">users</span><span class="p">[</span><span class="ss">:vip</span><span class="p">].</span><span class="nf">count</span><span class="p">.</span><span class="nf">as</span><span class="p">(</span><span class="s2">"count"</span><span class="p">)).</span><span class="nf">group</span><span class="p">(</span><span class="s2">"vip"</span><span class="p">)</span>
<span class="n">select_manager</span><span class="p">.</span><span class="nf">to_sql</span>
<span class="c1"># =&gt; SELECT "users"."vip" AS status, COUNT("users"."vip") AS count FROM "users"  GROUP BY vip</span>
</code></pre> <p>The <a href="https://github.com/rails/arel/blob/f50de54/lib/arel/math.rb">Arel::Math</a> module is pretty neat. It implements the common math operators so that we can use them directly on the attributes as if we&rsquo;re working with the values.</p> <pre class="highlight ruby"><code><span class="n">select_manager</span> <span class="o">=</span> <span class="n">users</span><span class="p">.</span><span class="nf">project</span><span class="p">((</span><span class="n">users</span><span class="p">[</span><span class="ss">:stared_comments_count</span><span class="p">]</span> <span class="o">/</span> <span class="n">users</span><span class="p">[</span><span class="ss">:comments_count</span><span class="p">]).</span><span class="nf">as</span><span class="p">(</span><span class="s2">"ratio"</span><span class="p">))</span>
<span class="n">select_manager</span><span class="p">.</span><span class="nf">to_sql</span>
<span class="c1"># =&gt; SELECT "users"."stared_comments_count" / "users"."comments_count" AS ratio FROM "users"</span>
</code></pre> <h2>Extending our index finger</h2> <p>Select queries which return data from the whole table are quite rare, usually you want to have more fine grained control. Let&rsquo;s see how Arel handles these cases. The starting point is again <a href="https://github.com/rails/arel/blob/f50de54/lib/arel/attributes/attribute.rb">Arel::Attribute</a>. More specifically, it&rsquo;s one of its included modules, <a href="https://github.com/rails/arel/blob/f50de54/lib/arel/predications.rb">Arel::Predications</a>. By looking at the code you can see a lot of handy methods, many of which do not have their equivalent in ActiveRecord&#39; APIs.</p> <pre class="highlight ruby"><code><span class="n">select_manager</span> <span class="o">=</span> <span class="n">users</span><span class="p">.</span><span class="nf">project</span><span class="p">(</span><span class="no">Arel</span><span class="p">.</span><span class="nf">star</span><span class="p">).</span><span class="nf">where</span><span class="p">(</span><span class="n">users</span><span class="p">[</span><span class="ss">:id</span><span class="p">].</span><span class="nf">eq</span><span class="p">(</span><span class="mi">23</span><span class="p">).</span><span class="nf">or</span><span class="p">(</span><span class="n">users</span><span class="p">[</span><span class="ss">:id</span><span class="p">].</span><span class="nf">eq</span><span class="p">(</span><span class="mi">42</span><span class="p">)))</span>
<span class="n">select_manager</span> <span class="o">=</span> <span class="n">users</span><span class="p">.</span><span class="nf">project</span><span class="p">(</span><span class="no">Arel</span><span class="p">.</span><span class="nf">star</span><span class="p">).</span><span class="nf">where</span><span class="p">(</span><span class="n">users</span><span class="p">[</span><span class="ss">:id</span><span class="p">].</span><span class="nf">eq_any</span><span class="p">([</span><span class="mi">23</span><span class="p">,</span> <span class="mi">42</span><span class="p">]))</span>
<span class="n">select_manager</span><span class="p">.</span><span class="nf">to_sql</span>
<span class="c1"># =&gt; SELECT * FROM "users"  WHERE ("users"."id" = 23 OR "users"."id" = 42)</span>
</code></pre> <p>For more complicated queries, it&rsquo;s usually best to the build the parts individually and combine them together at the end.</p> <pre class="highlight ruby"><code><span class="n">admins_vips</span>    <span class="o">=</span> <span class="n">users</span><span class="p">[</span><span class="ss">:admin</span><span class="p">].</span><span class="nf">eq</span><span class="p">(</span><span class="kp">true</span><span class="p">).</span><span class="nf">or</span><span class="p">(</span><span class="n">users</span><span class="p">[</span><span class="ss">:vip</span><span class="p">].</span><span class="nf">eq</span><span class="p">(</span><span class="kp">true</span><span class="p">))</span>
<span class="n">with_karma</span>     <span class="o">=</span> <span class="n">users</span><span class="p">[</span><span class="ss">:karma</span><span class="p">].</span><span class="nf">gteq</span><span class="p">(</span><span class="mi">5000</span><span class="p">).</span><span class="nf">and</span><span class="p">(</span><span class="n">users</span><span class="p">[</span><span class="ss">:hellbanned</span><span class="p">].</span><span class="nf">eq</span><span class="p">(</span><span class="kp">false</span><span class="p">))</span>

<span class="n">select_manager</span> <span class="o">=</span> <span class="n">users</span><span class="p">.</span><span class="nf">project</span><span class="p">(</span><span class="n">users</span><span class="p">[</span><span class="ss">:id</span><span class="p">]).</span><span class="nf">where</span><span class="p">(</span><span class="n">admins_vips</span><span class="p">.</span><span class="nf">or</span><span class="p">(</span><span class="n">with_karma</span><span class="p">)).</span><span class="nf">order</span><span class="p">(</span><span class="n">users</span><span class="p">[</span><span class="ss">:id</span><span class="p">].</span><span class="nf">desc</span><span class="p">)</span>
<span class="n">select_manager</span><span class="p">.</span><span class="nf">to_sql</span>
<span class="c1"># =&gt; SELECT COUNT("users"."id") FROM "users" WHERE (("users"."admin" = 't' OR "users"."vip" = 't')</span>
<span class="c1">#      OR "users"."karma" &gt;= 5000 AND "users"."hellbanned" = 'f')</span>
<span class="c1">#    ORDER BY "users"."id" DESC</span>
</code></pre> <h2>The more the merrier</h2> <p>Next, let&rsquo;s take a look at join statements. In line with the previously shown API, Arel <a href="https://github.com/rails/arel/blob/f50de54/lib/arel/select_manager.rb#L104-119">exposes joins</a> directly from <code>Arel::SelectManager</code>. As expected, Arel supports the usual <code>INNER JOIN</code>, and <code>LEFT</code>, <code>RIGHT</code>, <code>FULL</code> <code>OUTER JOIN</code> kinds.</p> <pre class="highlight ruby"><code><span class="n">comments</span>       <span class="o">=</span> <span class="no">Arel</span><span class="o">::</span><span class="no">Table</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:comments</span><span class="p">,</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">)</span>

<span class="n">select_manager</span> <span class="o">=</span> <span class="n">users</span><span class="p">.</span><span class="nf">project</span><span class="p">(</span><span class="no">Arel</span><span class="p">.</span><span class="nf">star</span><span class="p">).</span><span class="nf">join</span><span class="p">(</span><span class="n">comments</span><span class="p">).</span><span class="nf">on</span><span class="p">(</span><span class="n">users</span><span class="p">[</span><span class="ss">:id</span><span class="p">].</span><span class="nf">eq</span><span class="p">(</span><span class="n">comments</span><span class="p">[</span><span class="ss">:user_id</span><span class="p">]))</span>
<span class="n">select_manager</span><span class="p">.</span><span class="nf">to_sql</span>
<span class="c1"># =&gt; SELECT * FROM "users" INNER JOIN "comments" ON "users"."id" = "comments"."user_id"</span>
</code></pre> <p>To create the remaining kinds of joins, we need to explicitly pass a second argument to the <code>join</code> method.</p> <pre class="highlight ruby"><code><span class="n">select_manager</span> <span class="o">=</span> <span class="n">users</span><span class="p">.</span><span class="nf">project</span><span class="p">(</span><span class="no">Arel</span><span class="p">.</span><span class="nf">star</span><span class="p">).</span><span class="nf">join</span><span class="p">(</span><span class="n">comments</span><span class="p">,</span> <span class="no">Arel</span><span class="o">::</span><span class="no">Nodes</span><span class="o">::</span><span class="no">OuterJoin</span><span class="p">).</span>
  <span class="nf">on</span><span class="p">(</span><span class="n">users</span><span class="p">[</span><span class="ss">:id</span><span class="p">].</span><span class="nf">eq</span><span class="p">(</span><span class="n">comments</span><span class="p">[</span><span class="ss">:user_id</span><span class="p">])).</span>
  <span class="nf">having</span><span class="p">(</span><span class="n">comments</span><span class="p">[</span><span class="ss">:id</span><span class="p">].</span><span class="nf">count</span><span class="p">.</span><span class="nf">lteq</span><span class="p">(</span><span class="mi">16</span><span class="p">)).</span>
  <span class="nf">take</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>

<span class="n">select_manager</span><span class="p">.</span><span class="nf">to_sql</span>
<span class="c1"># =&gt; SELECT * FROM "users" LEFT OUTER JOIN "comments" ON "users"."id" = "comments"."user_id"</span>
<span class="c1">#    HAVING COUNT("comments"."id") &lt;= 16 LIMIT 15</span>
</code></pre> <p>Since the need for <code>OuterJoin</code> is very common, there&rsquo;s a shortcut called <a href="https://github.com/rails/arel/blob/f50de54/lib/arel/select_manager.rb#L117-119">outer_join</a>, which internally calls the <code>join</code> method with the <code>Arel::Nodes::OuterJoin</code> argument for us. To get the remaining kinds of joins, there are <code>Arel::Nodes::FullOuterJoin</code> and <code>Arel::Nodes::RightOuterJoin</code> nodes available.</p> <p>The rarely used <code>CROSS JOIN</code> kind is not directly supported. What&rsquo;s also not supported out of the box is the <code>USING</code> clause but as with the previous case, we can get around that by resorting to creating <code>Arel::Nodes::SqlLiteral</code> manually or better yet by rewriting the query to use the supported constructs.</p> <h2>There&rsquo;s always more</h2> <p>Arel comes with support even for slightly advanced features such as <code>WITH</code> statements or <code>WINDOW</code> functions. Let&rsquo;s try to replicate an example <a href="//www.postgresql.org/docs/9.3/static/queries-with.html">7.8.1. SELECT in WITH</a> from the PostgreSQL manual. The query is quite complicated, it consists of 2 <code>WITH</code> statements and a few subqueries. Let&rsquo;s focus first on the <code>WITH</code> clauses <code>regional_sales</code> and <code>top_regions</code>.</p> <pre class="highlight ruby"><code><span class="n">orders</span>          <span class="o">=</span> <span class="no">Arel</span><span class="o">::</span><span class="no">Table</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:orders</span><span class="p">,</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">)</span>
<span class="n">reg_sales</span>       <span class="o">=</span> <span class="no">Arel</span><span class="o">::</span><span class="no">Table</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:regional_sales</span><span class="p">,</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">)</span>
<span class="n">top_regions</span>     <span class="o">=</span> <span class="no">Arel</span><span class="o">::</span><span class="no">Table</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:top_regions</span><span class="p">,</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">)</span>

<span class="n">reg_sales_query</span> <span class="o">=</span> <span class="n">orders</span><span class="p">.</span><span class="nf">project</span><span class="p">(</span><span class="n">orders</span><span class="p">[</span><span class="ss">:region</span><span class="p">],</span> <span class="n">orders</span><span class="p">[</span><span class="ss">:amount</span><span class="p">].</span><span class="nf">sum</span><span class="p">.</span><span class="nf">as</span><span class="p">(</span><span class="s2">"total_sales"</span><span class="p">)).</span>
                    <span class="nf">group</span><span class="p">(</span><span class="n">orders</span><span class="p">[</span><span class="ss">:region</span><span class="p">])</span>
<span class="n">reg_sales_as</span>    <span class="o">=</span> <span class="no">Arel</span><span class="o">::</span><span class="no">Nodes</span><span class="o">::</span><span class="no">As</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">reg_sales</span><span class="p">,</span> <span class="n">reg_sales_query</span><span class="p">)</span>
</code></pre> <p>Nothing we haven&rsquo;t seen before. The only exception is the explicit instantiation of <code>Arel::Nodes::As</code>. There doesn&rsquo;t seem to be a way around it as you cannot create an alias via the usual <code>as</code> method.</p> <pre class="highlight ruby"><code><span class="n">top_regions_subquery</span> <span class="o">=</span> <span class="n">reg_sales</span><span class="p">.</span><span class="nf">project</span><span class="p">(</span><span class="no">Arel</span><span class="p">.</span><span class="nf">sql</span><span class="p">(</span><span class="s2">"SUM(total_sales) / 10"</span><span class="p">))</span>
<span class="n">top_regions_query</span>    <span class="o">=</span> <span class="n">reg_sales</span><span class="p">.</span><span class="nf">project</span><span class="p">(</span><span class="n">reg_sales</span><span class="p">[</span><span class="ss">:region</span><span class="p">]).</span>
                        <span class="nf">where</span><span class="p">(</span><span class="n">reg_sales</span><span class="p">[</span><span class="ss">:total_sales</span><span class="p">].</span><span class="nf">gt</span><span class="p">(</span><span class="n">top_regions_subquery</span><span class="p">))</span>
<span class="n">top_regions_as</span>       <span class="o">=</span> <span class="no">Arel</span><span class="o">::</span><span class="no">Nodes</span><span class="o">::</span><span class="no">As</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">top_regions</span><span class="p">,</span> <span class="n">top_regions_query</span><span class="p">)</span>
</code></pre> <p>The use of <a href="https://github.com/rails/arel/blob/f50de54/lib/arel.rb#L26-L28">Arel.sql</a> is not ideal, however, as with the previous part, there is not a way to use math operations on the result of the <code>sum</code> call.</p> <pre class="highlight ruby"><code><span class="n">attributes</span> <span class="o">=</span> <span class="p">[</span><span class="n">orders</span><span class="p">[</span><span class="ss">:region</span><span class="p">],</span> <span class="n">orders</span><span class="p">[</span><span class="ss">:product</span><span class="p">],</span> <span class="n">orders</span><span class="p">[</span><span class="ss">:quantity</span><span class="p">].</span><span class="nf">as</span><span class="p">(</span><span class="s2">"product_units"</span><span class="p">),</span>
               <span class="n">orders</span><span class="p">[</span><span class="ss">:amount</span><span class="p">].</span><span class="nf">as</span><span class="p">(</span><span class="s2">"product_sales"</span><span class="p">)]</span>

<span class="n">res</span> <span class="o">=</span> <span class="n">orders</span><span class="p">.</span><span class="nf">project</span><span class="p">(</span><span class="o">*</span><span class="n">attributes</span><span class="p">).</span><span class="nf">where</span><span class="p">(</span><span class="n">orders</span><span class="p">[</span><span class="ss">:region</span><span class="p">].</span><span class="nf">in</span><span class="p">(</span><span class="n">top_regions</span><span class="p">.</span><span class="nf">project</span><span class="p">(</span><span class="n">top_regions</span><span class="p">[</span><span class="ss">:region</span><span class="p">]))).</span>
        <span class="nf">with</span><span class="p">([</span><span class="n">reg_sales_as</span><span class="p">,</span> <span class="n">top_regions_as</span><span class="p">]).</span><span class="nf">group</span><span class="p">(</span><span class="n">orders</span><span class="p">[</span><span class="ss">:region</span><span class="p">],</span> <span class="n">orders</span><span class="p">[</span><span class="ss">:product</span><span class="p">])</span>

<span class="n">res</span><span class="p">.</span><span class="nf">to_sql</span>
</code></pre> <p>With all of that in place, we have our final query. If we look at the parts individually, they are pretty simple. Overall, however, the code is longer than a pure SQL solution. The fact doesn&rsquo;t matter when using Arel pragmatically but if composed by hand, one has to always consider whether it&rsquo;s actually worth the effort.</p> <h2>SelectManager is not the only one</h2> <p>So far all we&rsquo;ve been doing was writing select queries via <code>SelectManager</code>, but Arel of course supports the other operations as well. Let&rsquo;s quickly take a look at deleting. There are two ways you can create a delete query. The first way is to explicitly instantiate <a href="https://github.com/rails/arel/blob/f50de54/lib/arel/delete_manager.rb">Arel::DeleteManager</a>.</p> <pre class="highlight ruby"><code><span class="n">delete_manager</span> <span class="o">=</span> <span class="no">Arel</span><span class="o">::</span><span class="no">DeleteManager</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">)</span>
<span class="n">delete_manager</span><span class="p">.</span><span class="nf">from</span><span class="p">(</span><span class="n">users</span><span class="p">).</span><span class="nf">where</span><span class="p">(</span><span class="n">users</span><span class="p">[</span><span class="ss">:id</span><span class="p">].</span><span class="nf">eq_any</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">]))</span>
<span class="n">delete_manager</span><span class="p">.</span><span class="nf">to_sql</span>
<span class="c1"># =&gt; DELETE FROM "users" WHERE ("users"."id" = 4 OR "users"."id" = 8)</span>
</code></pre> <p>The other way, although it seems deprecated, is to create the delete statement from a select statement by calling <a href="https://github.com/rails/arel/blob/f50de54/lib/arel/crud.rb#L32-37">compile_delete</a> (there are similar methods for the other operations as well). By looking at the code we can see that all it does is pick values out of the object it&rsquo;s mixed into (<code>Arel::SelectManager</code>) and passing it to a new instance of <code>Arel::DeleteManager</code>.</p> <pre class="highlight ruby"><code><span class="n">select_manager</span> <span class="o">=</span> <span class="n">users</span><span class="p">.</span><span class="nf">project</span><span class="p">(</span><span class="n">users</span><span class="p">[</span><span class="ss">:id</span><span class="p">],</span> <span class="n">users</span><span class="p">[</span><span class="ss">:name</span><span class="p">]).</span><span class="nf">where</span><span class="p">(</span><span class="n">users</span><span class="p">[</span><span class="ss">:banned</span><span class="p">].</span><span class="nf">eq</span><span class="p">(</span><span class="kp">true</span><span class="p">))</span>
<span class="n">select_manager</span><span class="p">.</span><span class="nf">to_sql</span>
<span class="c1"># =&gt; SELECT "users"."id", "users"."name" FROM "users"  WHERE "users"."banned = 't'</span>

<span class="n">delete_manager</span> <span class="o">=</span> <span class="n">select_manager</span><span class="p">.</span><span class="nf">compile_delete</span>
<span class="n">delete_manager</span><span class="p">.</span><span class="nf">to_sql</span>
<span class="c1"># =&gt; DELETE FROM "users" WHERE "users"."banned" = 't'</span>
</code></pre> <p>The managers for the remaining operations, <a href="https://github.com/rails/arel/blob/f50de54/lib/arel/insert_manager.rb">InsertManager</a> and <a href="https://github.com/rails/arel/blob/f50de54/lib/arel/update_manager.rb">UpdateManager</a>, work in a similar fashion.</p> <pre class="highlight ruby"><code><span class="n">insert_manager</span> <span class="o">=</span> <span class="no">Arel</span><span class="o">::</span><span class="no">InsertManager</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">)</span>
<span class="n">insert_manager</span><span class="p">.</span><span class="nf">insert</span><span class="p">([[</span><span class="n">users</span><span class="p">[</span><span class="ss">:name</span><span class="p">],</span> <span class="s2">"Bob"</span><span class="p">],</span> <span class="p">[</span><span class="n">users</span><span class="p">[</span><span class="ss">:admin</span><span class="p">],</span> <span class="kp">true</span><span class="p">]])</span>
<span class="n">insert_manager</span><span class="p">.</span><span class="nf">to_sql</span>
<span class="c1"># =&gt; INSERT INTO "users" ("name", "admin) VALUES ('Bob', 't')</span>
</code></pre> <p>Notice that <code>Arel::InsertManager</code> is able to figure out the name of the table we&rsquo;re inserting to automatically through the use of <code>Arel::Attribute</code>. If we&rsquo;re to use string literals instead, we&rsquo;d have to specify the table name via the <a href="https://github.com/rails/arel/blob/f50de54/lib/arel/insert_manager.rb#L8-11">into</a> method. The same is not offered in <code>Arel::UpdateManager</code> and we have to use <a href="https://github.com/rails/arel/blob/f50de54/lib/arel/update_manager.rb#L29-32">table</a>.</p> <pre class="highlight ruby"><code><span class="n">update_manager</span> <span class="o">=</span> <span class="no">Arel</span><span class="o">::</span><span class="no">UpdateManager</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">)</span>
<span class="n">update_manager</span><span class="p">.</span><span class="nf">table</span><span class="p">(</span><span class="n">users</span><span class="p">).</span><span class="nf">where</span><span class="p">(</span><span class="n">users</span><span class="p">[</span><span class="ss">:id</span><span class="p">].</span><span class="nf">eq</span><span class="p">(</span><span class="mi">42</span><span class="p">))</span>
<span class="n">update_manager</span><span class="p">.</span><span class="nf">set</span><span class="p">([[</span><span class="n">users</span><span class="p">[</span><span class="ss">:name</span><span class="p">],</span> <span class="s2">"Bob"</span><span class="p">],</span> <span class="p">[</span><span class="n">users</span><span class="p">[</span><span class="ss">:admin</span><span class="p">],</span> <span class="kp">true</span><span class="p">]])</span>
<span class="n">update_manager</span><span class="p">.</span><span class="nf">to_sql</span>
<span class="c1"># =&gt; UPDATE "users" SET "name" = 'Bob', "admin" = 't' WHERE "users"."id" = 42</span>
</code></pre> <h2>The story of <code>.to_sql</code></h2> <p>Throughout the article we&rsquo;ve been calling <code>.to_sql</code> in almost every example and never actually talked about how it works. As mentioned in the beginning, Arel internally represents all queries as nodes in an abstract syntax tree. The managers create and modify these trees. Naturally, something later has to take the resulting tree and process it to the final output. Arel uses various kinds of visitors to accomplish this (see the <a href="//en.wikipedia.org/wiki/Visitor_pattern">Visitor pattern</a>).</p> <p>In essence, the visitor pattern abstracts away how the nodes of an AST are processed from the nodes themselves. The nodes stay the same, yet it&rsquo;s possible to apply different visitors and get different results. This is exactly what Arel needs to generate all those kinds of output formats.</p> <p>The Arel&rsquo;s implementation of the visitor pattern is interesting. It uses a variation called <a href="//web.info.uvt.ro/~oaritoni/inginerie/Cursuri/DesignPatterns/L7/Visitor/nordberg.ps.pdf">Extrinsic Visitor</a>. The variation takes great advantage of Ruby&rsquo;s dynamic behavior and the information available at runtime. Instead of forcing the nodes to implement the <code>accept</code> method, the visitor calls <a href="https://github.com/rails/arel/blob/f50de54/lib/arel/visitors/visitor.rb#L4-6">accept</a> on itself with the root node as argument. It then inspects the node to find out its type and <a href="https://github.com/rails/arel/blob/f50de54/lib/arel/visitors/visitor.rb#L21-31">looks</a> the appropriate visit method. To make the dispatching part faster, the code uses a simple <a href="https://github.com/rails/arel/blob/f50de54/lib/arel/visitors/visitor.rb#L10-L15">hash table</a> for caching purposes.</p> <pre class="highlight ruby"><code><span class="p">{</span>
  <span class="no">Arel</span><span class="o">::</span><span class="no">Visitors</span><span class="o">::</span><span class="no">SQLite</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="no">Arel</span><span class="o">::</span><span class="no">Nodes</span><span class="o">::</span><span class="no">SelectStatement</span> <span class="o">=&gt;</span> <span class="s2">"visit_Arel_Nodes_SelectStatement"</span><span class="p">,</span>
    <span class="no">Arel</span><span class="o">::</span><span class="no">Nodes</span><span class="o">::</span><span class="no">SqlLiteral</span>      <span class="o">=&gt;</span> <span class="s2">"visit_Arel_Nodes_SqlLiteral"</span><span class="p">,</span>
    <span class="no">Arel</span><span class="o">::</span><span class="no">Nodes</span><span class="o">::</span><span class="no">Or</span>              <span class="o">=&gt;</span> <span class="s2">"visit_Arel_Nodes_Or"</span><span class="p">,</span>
    <span class="no">Arel</span><span class="o">::</span><span class="no">Attributes</span><span class="o">::</span><span class="no">Attribute</span>  <span class="o">=&gt;</span> <span class="s2">"visit_Arel_Attributes_Attribute"</span><span class="p">,</span>
    <span class="no">Arel</span><span class="o">::</span><span class="no">Nodes</span><span class="o">::</span><span class="no">InnerJoin</span>       <span class="o">=&gt;</span> <span class="s2">"visit_Arel_Nodes_InnerJoin"</span><span class="p">,</span>
    <span class="no">Arel</span><span class="o">::</span><span class="no">Nodes</span><span class="o">::</span><span class="no">Having</span>          <span class="o">=&gt;</span> <span class="s2">"visit_Arel_Nodes_Having"</span><span class="p">,</span>
    <span class="no">Arel</span><span class="o">::</span><span class="no">Nodes</span><span class="o">::</span><span class="no">Limit</span>           <span class="o">=&gt;</span> <span class="s2">"visit_Arel_Nodes_Limit"</span>
    <span class="no">Fixnum</span>                       <span class="o">=&gt;</span> <span class="s2">"visit_Fixnum"</span><span class="p">,</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre> <p>If we look into the <a href="https://github.com/rails/arel/tree/f50de54/lib/arel/visitors">visitors directory</a>, we can see a few visitors that Arel comes with by default. Some of them directly correspond to a particular database, some are used only internally and some are used only from AR. Notice that all database related visitors inherit from the <a href="https://github.com/rails/arel/blob/f50de54/lib/arel/visitors/to_sql.rb">to_sql</a> visitor, which is doing most of the work, and that the particular database visitor handles only the differences specific to the concrete database. Let&rsquo;s create a select manager and get the SQL query out of it without the <code>to_sql</code> method.</p> <pre class="highlight ruby"><code><span class="n">select_manager</span> <span class="o">=</span> <span class="n">users</span><span class="p">.</span><span class="nf">project</span><span class="p">(</span><span class="no">Arel</span><span class="p">.</span><span class="nf">star</span><span class="p">)</span>
<span class="n">select_manager</span><span class="p">.</span><span class="nf">to_sql</span>
<span class="c1"># =&gt; SELECT * FROM "users"</span>

<span class="n">sqlite_visitor</span> <span class="o">=</span> <span class="no">Arel</span><span class="o">::</span><span class="no">Visitors</span><span class="o">::</span><span class="no">SQLite</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">.</span><span class="nf">connection</span><span class="p">)</span>
<span class="n">collector</span>      <span class="o">=</span> <span class="no">Arel</span><span class="o">::</span><span class="no">Collectors</span><span class="o">::</span><span class="no">SQLString</span><span class="p">.</span><span class="nf">new</span>
<span class="n">collector</span>      <span class="o">=</span> <span class="n">sqlite_visitor</span><span class="p">.</span><span class="nf">accept</span><span class="p">(</span><span class="n">select_manager</span><span class="p">.</span><span class="nf">ast</span><span class="p">,</span> <span class="n">collector</span><span class="p">)</span>
<span class="n">collector</span><span class="p">.</span><span class="nf">value</span>
<span class="c1"># =&gt; SELECT * FROM "users"</span>
</code></pre> <p>A collector is an object that gathers the results as they come in from the visitor. In this particular example, <code>collector</code> could have been a Ruby&rsquo;s own String and we&rsquo;d get the same result (without calling the final <code>value</code> of course). If we look at the actual <a href="https://github.com/rails/arel/blob/f50de54/lib/arel/tree_manager.rb#L27-L31">source code</a> of <code>to_sql</code>, we can see that it does the same except it gets the visitor directly from the connection.</p> <p>Let&rsquo;s take a look at one more visitor, <a href="https://github.com/rails/arel/blob/f50de54/lib/arel/visitors/dot.rb">Arel::Visitors::Dot</a>. The visitor generates the Graphviz&rsquo;s Dot format and we can use it to create diagrams out of an AST. To make things easier, there&rsquo;s a convenient <a href="https://github.com/rails/arel/blob/f50de54/lib/arel/tree_manager.rb#L17-L19">to_dot</a> method we can use. We take the output and save it to a file.</p> <pre class="highlight ruby"><code><span class="no">File</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="s2">"arel.dot"</span><span class="p">,</span> <span class="n">select_manager</span><span class="p">.</span><span class="nf">to_dot</span><span class="p">)</span>
</code></pre> <p>On the command line, we use the <code>dot</code> utility to convert the result to an image.</p> <pre class="highlight shell"><code>dot arel.dot -T png -o arel.png
</code></pre> <div class=image> <a href="/images/arel/arel_to_dot-1af28ad9.png"> <img src="/images/arel/arel_to_dot_small-1e03547a.png" title=fu /> </a> </div> <h2>Back to upper levels</h2> <p>We have all this power at our disposal at the Arel level but how can we leverage it with ActiveRecord? Turns out that we can very easily get the underlying <code>Arel::Table</code> directly from our models with <code>&lt;Table&gt;.arel_table</code>. What&rsquo;s even better is that we can get the AST from our ActiveRecord&rsquo;s queries and manipulate it. A word of warning though, working with the underlying Arel object is not officially supported and things may change between releases without notice.</p> <p>First, we need a few throw-away tables and the corresponding ActiveRecord objects to work against. Let&rsquo;s go again with users and comments.</p> <pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">connection</span><span class="p">.</span><span class="nf">create_table</span> <span class="n">table_name</span><span class="p">,</span> <span class="ss">force: </span><span class="kp">true</span> <span class="k">do</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span>
    <span class="n">t</span><span class="p">.</span><span class="nf">string</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">null: </span><span class="kp">false</span>
    <span class="n">t</span><span class="p">.</span><span class="nf">integer</span> <span class="ss">:karma</span><span class="p">,</span> <span class="ss">null: </span><span class="kp">false</span><span class="p">,</span> <span class="ss">default: </span><span class="mi">0</span>
    <span class="n">t</span><span class="p">.</span><span class="nf">boolean</span> <span class="ss">:vip</span><span class="p">,</span> <span class="ss">null: </span><span class="kp">false</span><span class="p">,</span> <span class="ss">default: </span><span class="kp">false</span>
    <span class="n">t</span><span class="p">.</span><span class="nf">timestamps</span>
  <span class="k">end</span>

  <span class="n">create!</span> <span class="p">[{</span><span class="ss">name: </span><span class="s2">"Alice"</span><span class="p">,</span> <span class="ss">karma: </span><span class="mi">999</span><span class="p">,</span> <span class="ss">vip: </span><span class="kp">true</span><span class="p">},</span> <span class="p">{</span><span class="ss">name: </span><span class="s2">"Bob"</span><span class="p">,</span> <span class="ss">karma: </span><span class="mi">1000</span><span class="p">},</span> <span class="p">{</span><span class="ss">name: </span><span class="s2">"Charlie"</span><span class="p">}]</span>

  <span class="n">has_many</span> <span class="ss">:comments</span><span class="p">,</span> <span class="ss">dependent: :delete_all</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Comment</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">connection</span><span class="p">.</span><span class="nf">create_table</span> <span class="n">table_name</span><span class="p">,</span> <span class="ss">force: </span><span class="kp">true</span> <span class="k">do</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span>
    <span class="n">t</span><span class="p">.</span><span class="nf">text</span> <span class="ss">:text</span><span class="p">,</span> <span class="ss">null: </span><span class="kp">false</span>
    <span class="n">t</span><span class="p">.</span><span class="nf">integer</span> <span class="ss">:points</span><span class="p">,</span> <span class="ss">null: </span><span class="kp">false</span><span class="p">,</span> <span class="ss">default: </span><span class="mi">0</span>
    <span class="n">t</span><span class="p">.</span><span class="nf">references</span> <span class="ss">:user</span>
    <span class="n">t</span><span class="p">.</span><span class="nf">timestamps</span>
  <span class="k">end</span>

  <span class="n">belongs_to</span> <span class="ss">:user</span>
<span class="k">end</span>
</code></pre> <p>As mentioned in the previous paragraph, we can get the <code>Arel::Table</code> object out by calling <a href="https://github.com/rails/rails/blob/178448/activerecord/lib/active_record/core.rb#L216-L218">arel_table</a> on the model. Once we do that, we can use the same methods as we&rsquo;ve been using so far throughout the text.</p> <pre class="highlight ruby"><code><span class="n">u</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">arel_table</span>
<span class="no">User</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="ss">:karma</span><span class="p">].</span><span class="nf">gteq</span><span class="p">(</span><span class="mi">1000</span><span class="p">).</span><span class="nf">or</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="ss">:vip</span><span class="p">].</span><span class="nf">eq</span><span class="p">(</span><span class="kp">true</span><span class="p">))).</span><span class="nf">to_a</span>
<span class="c1"># =&gt; [#&lt;User id: 1, name: "Alice"...&gt;, #&lt;User id: 2, name: "Bob"...&gt;]</span>
</code></pre> <p>Here we&rsquo;re passing an Arel node (<code>Arel::Nodes::Grouping</code>) directly to AR&rsquo;s <code>where</code>. No need to convert anything as AR knows how to deal with these objects. Let&rsquo;s switch the sides and use an AR query inside an Arel one.</p> <pre class="highlight ruby"><code><span class="no">User</span><span class="p">.</span><span class="nf">first</span><span class="p">.</span><span class="nf">comments</span><span class="p">.</span><span class="nf">create!</span> <span class="ss">text: </span><span class="s2">"Sample text!"</span><span class="p">,</span> <span class="ss">points: </span><span class="mi">1001</span>

<span class="n">c</span>             <span class="o">=</span> <span class="no">Comment</span><span class="p">.</span><span class="nf">arel_table</span>
<span class="n">popular_users</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="ss">:id</span><span class="p">).</span><span class="nf">order</span><span class="p">(</span><span class="ss">karma: :desc</span><span class="p">).</span><span class="nf">limit</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">comments</span>      <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="nf">project</span><span class="p">(</span><span class="no">Arel</span><span class="p">.</span><span class="nf">star</span><span class="p">).</span><span class="nf">where</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="ss">:points</span><span class="p">].</span><span class="nf">gt</span><span class="p">(</span><span class="mi">1000</span><span class="p">).</span><span class="nf">and</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="ss">:user_id</span><span class="p">].</span><span class="nf">in</span><span class="p">(</span><span class="n">popular_users</span><span class="p">.</span><span class="nf">ast</span><span class="p">)))</span>

<span class="no">Comment</span><span class="p">.</span><span class="nf">find_by_sql</span><span class="p">(</span><span class="n">comments</span><span class="p">.</span><span class="nf">to_sql</span><span class="p">)</span>
</code></pre> <p>To execute Arel queries, we first need to get the SQL out of Arel and then feed it into <a href="https://github.com/rails/rails/blob/178448/activerecord/lib/active_record/querying.rb#L38-L49">find_by_sql</a>. Notice that we called <code>ast</code> on <code>popular_users</code> before passing it to Arel&rsquo;s <code>in</code>. That&rsquo;s because <code>popular_users</code> is an instance of <code>ActiveRecord::Relation</code> and we need to get the underlying Arel AST.</p> <p>There of course comes a time when you need to issue a query that doesn&rsquo;t necessarily result in records coming back. In that case, we can use the connection directly and call <code>execute</code> with the SQL as the argument.</p> <pre class="highlight ruby"><code><span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">.</span><span class="nf">connection</span><span class="p">.</span><span class="nf">execute</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="ss">:id</span><span class="p">].</span><span class="nf">eq</span><span class="p">(</span><span class="mi">1</span><span class="p">)).</span><span class="nf">compile_delete</span><span class="p">.</span><span class="nf">to_sql</span><span class="p">)</span>
</code></pre> <p>One issue you may run into when using ActiveRecord 4.1.x is that calling <code>to_sql</code> might return an SQL query with bind parameters instead of the actual values. The issue has been solved on the current master branch and will be part of the next release. To get around that issue now however, we must use <code>unprepared_statement</code>.</p> <pre class="highlight ruby"><code><span class="c1"># ActiveRecord 4.1.x</span>

<span class="n">sql</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">first</span><span class="p">.</span><span class="nf">comments</span><span class="p">.</span><span class="nf">to_sql</span>
<span class="c1"># =&gt; SELECT "comments".* FROM "comments"  WHERE "comments"."user_id" = ?</span>

<span class="n">sql</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">connection</span><span class="p">.</span><span class="nf">unprepared_statement</span> <span class="p">{</span>
  <span class="no">User</span><span class="p">.</span><span class="nf">first</span><span class="p">.</span><span class="nf">comments</span><span class="p">.</span><span class="nf">to_sql</span>
<span class="p">}</span>
<span class="c1"># =&gt; SELECT "comments".* FROM "comments"  WHERE "comments"."user_id" = 1</span>
</code></pre> <p>The code in the <code>unprepared_statement</code> block gets evaluated with a visitor that mixes in <a href="https://github.com/rails/arel/blob/f50de54/lib/arel/visitors/bind_visitor.rb">Arel::Visitors::BindVisitor</a>, which immediately resolves the bind parameters.</p> <h2>Real world</h2> <p>Having covered all of that, how do we use this in a real word application so that the code is maintainable and won&rsquo;t become a mess? One way of doing it is to create a class that will represent our query. Let&rsquo;s take a look at a simple example.</p> <pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">PrivilegedUsersQuery</span>
  <span class="kp">attr_reader</span> <span class="ss">:relation</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">relation</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">all</span><span class="p">)</span>
    <span class="vi">@relation</span> <span class="o">=</span> <span class="n">relation</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">find_each</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
    <span class="n">relation</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="n">privileged_users</span><span class="p">).</span><span class="nf">find_each</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="kp">private</span>

  <span class="k">def</span> <span class="nf">privileged_users</span>
    <span class="n">with_high_karma</span><span class="p">.</span><span class="nf">or</span> <span class="n">with_vip</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">with_high_karma</span>
    <span class="n">table</span><span class="p">[</span><span class="ss">:karma</span><span class="p">].</span><span class="nf">gt</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">with_vip</span>
    <span class="n">table</span><span class="p">[</span><span class="ss">:vip</span><span class="p">].</span><span class="nf">eq</span><span class="p">(</span><span class="kp">true</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">table</span>
    <span class="no">User</span><span class="p">.</span><span class="nf">arel_table</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre> <p>We take full advantage of the fact that we can build queries iteratively and dedicate a method to each part or similar, whatever feels like the best approach for the particular situation.</p> <pre class="highlight ruby"><code><span class="no">PrivilegedUsersQuery</span><span class="p">.</span><span class="nf">new</span><span class="p">.</span><span class="nf">find_each</span> <span class="k">do</span> <span class="o">|</span><span class="n">user</span><span class="o">|</span>
 <span class="c1"># ...</span>
<span class="k">end</span>
</code></pre> <h2>The end</h2> <p><a href="https://github.com/rails/arel">Arel</a> is a great tool to build abstractions upon and a powerful helper when the abstractions fail to provide the functionality you need. By now you know everything there&rsquo;s to know to use Arel effectively and most importantly you know where to look for answers when constructing a complicated query or when things go wrong. Please let me know if you found an error of any kind or have other suggestions.</p> <div class=social-share-icons><a href="https://twitter.com/share?url=http%3A%2F%2Fjpospisil.com%2F2014%2F06%2F16%2Fthe-definitive-guide-to-arel-the-sql-manager-for-ruby.html&text=The+definitive+guide+to+Arel%2C+the+SQL+manager+for+Ruby via @JiriPospisil" target=_blank><i class="fa fa-twitter-square"></i></a><a href="https://plus.google.com/share?url=http%3A%2F%2Fjpospisil.com%2F2014%2F06%2F16%2Fthe-definitive-guide-to-arel-the-sql-manager-for-ruby.html" target=_blank><i class="fa fa-google-plus-square"></i></a><a href="//www.facebook.com/sharer/sharer.php?s=100&p[url]=http%3A%2F%2Fjpospisil.com%2F2014%2F06%2F16%2Fthe-definitive-guide-to-arel-the-sql-manager-for-ruby.html&p[title]=The+definitive+guide+to+Arel%2C+the+SQL+manager+for+Ruby" target=_blank><i class="fa fa-facebook-square"></i></a></div><div class=twitter-contact><p>If you've enjoyed the article, you should follow <a href="https://twitter.com/JiriPospisil">@JiriPospisil</a> on Twitter and subscribe via <a href="/feed.xml">feed</a>.</p></div><footer><div class=row><div class="col-sm-5 col-sm-offset-1"><h5>Recent articles</h5><ul><li><a href="/2017/06/02/understanding-lock-files-in-npm-5.html">Understanding lock files in NPM 5</a></li><li><a href="/2014/06/16/the-definitive-guide-to-arel-the-sql-manager-for-ruby.html">The definitive guide to Arel, the SQL manager for Ruby</a></li><li><a href="/2014/03/16/replacing-make-with-ninja.html">Replacing Make with Ninja</a></li></ul></div><div class="col-sm-5 col-sm-offset-1"><h5>Archives</h5><ul><li><a href="/2017.html">2017 (1)</a></li><li><a href="/2014.html">2014 (2)</a></li></ul></div></div><div class=row><div class="col-sm-12 text-center"><p>&copy; Copyright 2017, Jiří Pospíšil</p></div></div></footer></div></div></div><script>window._gaq = window._gaq || [];
window._gaq.push(['_setAccount', 'UA-36750151-1']);
window._gaq.push(['_trackPageview']);

(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();</script></body></html>